var documenterSearchIndex = {"docs":
[{"location":"manual/profiles/#man-prof","page":"Time profiles","title":"Time profiles","text":"","category":"section"},{"location":"manual/profiles/","page":"Time profiles","title":"Time profiles","text":"To provide data for different time structures there is a flexible system of different time profiles that can be indexed by time periods.","category":"page"},{"location":"manual/profiles/","page":"Time profiles","title":"Time profiles","text":"FixedProfile: Time profile with the same value for all time periods\nOperationalProfile: Time profile with values varying with operational time periods\nScenarioProfile: Holds a separate time profile for each operational scenario\nRepresentativeProfile: Holds a separate time profile for each representative period\nStrategicProfile : Holds a separate time profile for each strategic period\nStrategicStochasticProfile : Holds a separate time profile for each strategic node in a strategic tree","category":"page"},{"location":"manual/profiles/","page":"Time profiles","title":"Time profiles","text":"The following code example shows how these profile types can be combined in a flexible manner to produce different overall profiles.","category":"page"},{"location":"manual/profiles/","page":"Time profiles","title":"Time profiles","text":"rep_periods = RepresentativePeriods(2, 365, [0.6, 0.4], [SimpleTimes(7,1), SimpleTimes(7,1)])\nperiods = TwoLevel(2, 365, rep_periods)\n\ncost = StrategicProfile(\n            [\n                RepresentativeProfile(\n                    [\n                        OperationalProfile([3, 3, 4, 3, 4, 6, 5]),\n                        FixedProfile(5)\n                    ]\n                ),\n                FixedProfile(7)\n            ]\n        )","category":"page"},{"location":"manual/profiles/","page":"Time profiles","title":"Time profiles","text":"Illustration of profile values for the various time periods as defined in the profile example (Image: Time profile values)","category":"page"},{"location":"showcases/emx/#show-emx","page":"EnergyModelsX","title":"EnergyModelsX","text":"","category":"section"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"EnergyModelsX (EMX) is a flexible multi-horizon energy system optimization framework using JuMP. It utilizes TimeStruct from the beginning and influenced some of the added features of TimeStruct. Its implemtation is outlined in the following sections.","category":"page"},{"location":"showcases/emx/#show-emx-core","page":"EnergyModelsX","title":"Implementation of the core structures","text":"","category":"section"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"The core package EnergyModelsBase differentiates between variables indexed over strategic periods and variables indexed over operational period, similar to the battery sizing example. As an example, consider the following two functions for variable declaration for a given ùíØ::TimeStructure:","category":"page"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"variables_capacity(m, ùí©::Vector{<:Node}, ùí≥·µõ·µâ·∂ú, ùíØ, modeltype::EnergyModel) with, among others,\n@variable(m, cap_use[ùí©·∂ú·µÉ·µñ, ùíØ] >= 0)\n@variable(m, cap_inst[ùí©·∂ú·µÉ·µñ, ùíØ] >= 0)\nvariables_opex(m, ùí©::Vector{<:Node}, ùí≥·µõ·µâ·∂ú, ùíØ, modeltype::EnergyModel) with, among others,\nùíØ·¥µ‚Åø·µõ = strategic_periods(ùíØ)\n@variable(m, opex_var[ùí©·µí·µñ·µâÀ£, ùíØ·¥µ‚Åø·µõ])","category":"page"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"These two functions highlight the simplicity of using TimeStruct as the individual time structures allow for iterations within JuMP macros. In addition, it simplifies the index sets as changing the number of intermediate time structures through incorporating, e.g., OperationalScenarios, does not require changes to the variable declarations. The change in the structure through the incorporation of the operational scenarios is instead available within the individual TimePeriod type.","category":"page"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"The same is also true for constraint functions as shown in constraints_capacity(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel):","category":"page"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"@constraint(m, [t ‚àà ùíØ], m[:cap_use][n, t] <= m[:cap_inst][n, t])","category":"page"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"Variables whose values are dependent on the previous operational period are only available for Storage nodes. Its implementation is rather complex, but it is entirely relying on the withprev functionality to decide whether it is the first operational period in a different TimeStructure as well as how it must behave in this situation.","category":"page"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"The individual operational periods are linked in EnergyModelsBase through the internal function scale_op_sp for the multiplication","category":"page"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"duration(t) * multiple_strat(t_inv t) * probability(t)","category":"page"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"where t corresponds to an operational period and t_inv to a strategic period.","category":"page"},{"location":"showcases/emx/#show-emx-adv","page":"EnergyModelsX","title":"Advanced utilization","text":"","category":"section"},{"location":"showcases/emx/#show-emx-adv-withprev","page":"EnergyModelsX","title":"withprev and its application","text":"","category":"section"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"As outlined, neither OperationalScenarios or RepresentativePeriods where available in the initial development of EMX. However, the adjustments towards including these were limited to constraints that require the previous periods, that is constraints declared through the withprev functionality. All other constraints did not require any changes as the respective TimePeriods included the required information.","category":"page"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"The implementation of the the Storage level balance provides an example on how TimeStruct can be used. It iterates through all potential subtypes of the given TimeStructure. Multiple dispatch is included to identify whether the TimeStructure includes OperationalScenarios or RepresentativePeriods. If this is the case, additional constraints can be incorporated. Due to the iteration (and storing) of all previous periods, it is possible to identify exactly what constraint should be utilized for the first operational period in a given TimeStructure.","category":"page"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"tip: Proposed workflow\nWhile it can be tempting to design models from the initial stage to include both operational scenarios and representative periods, it is beneficial to avoid including these. TimeStruct simplifies the introduction of either TimeStructure in a latter stage. It is hence significantly easier to develop a model without considering complex time structures.If you do not have any constraints depending on the previous periods, you even do not have to do any changes to your model when including OperationalScenarios or RepresentativePeriods.","category":"page"},{"location":"showcases/emx/#show-emx-adv-chunk","page":"EnergyModelsX","title":"Chunks for unit commitment","text":"","category":"section"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"The functionality of TimeStruct for chunks based on the minimum required time is utilized in the unit commitment constraints of Reformer nodes in EnergyModelsHydrogen. In this context, we require a minimum time for starting the node, shutting the node down, and when the node is offline due to limitations in the dynamics of the chemical plant.","category":"page"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"The used approach is similar to the Storage level balance utilizing the withprev functionality for the majority of the time structures. However, once on the lowest level, chunk_duration is used in addition to provide limits on changes between the different states. The eltypes of the iterator allows for further iterations to have access to the number of operational periods.","category":"page"},{"location":"showcases/emx/#show-emx-adv-strat","page":"EnergyModelsX","title":"Including strategic uncertainty","text":"","category":"section"},{"location":"showcases/emx/","page":"EnergyModelsX","title":"EnergyModelsX","text":"EMX was not tested to also include strategic uncertainty as described in TwoLevelTree structure. The basic functionalities of EnergyModelsBase and the majority of the developed packages do however not have any problems with incorporating strategic uncertainty as the strategic periods are not linked. In this case, the internal structure of TimeStruct allows the direct inclusion of strategic uncertainty without changes to the model. The exception if when using the withprev functionality on strategic periods as it is the case for the investments in EnergyModelsInvestments. However, it is expected that the inclusion does not require any changes directly to the code structure due to the function overload on the withprev functionality.","category":"page"},{"location":"tutorials/basic_usage/#Basic-Usage","page":"Basic usage","title":"Basic Usage","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"This tutorial demonstrates the basic usage of generating flexible optimization models using the TimeStruct package in combination with JuMP.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"using TimeStruct, JuMP","category":"page"},{"location":"tutorials/basic_usage/#Time-structures-and-time-profiles","page":"Basic usage","title":"Time structures and time profiles","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"We start by defining a simple time structure with 4 periods of varying duration","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"simple = SimpleTimes(4, [1, 2, 3, 2])","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"The time structure can be iterated over to access the periods and the duration can be queried for each period.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"print([duration(t) for t in simple])","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"The time periods can be used for lookups in time profiles of various types. For example, a fixed cost profile can be defined with a constant cost of 2.0 for all periods.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"cost_fixed = FixedProfile(2.0)\nprint([cost_fixed[t] for t in simple])","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"A dynamic cost profile can be defined with varying costs for each period.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"cost_dynamic = OperationalProfile([1.0, 2.0, 3.0, 2.0])\nprint([cost_dynamic[t] for t in simple])","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"One of the main purposes of the TimeStruct package is to facilitate the modeling of optimization problems with multiple time horizons. For this, we define a two-level time structure with 2 strategic periods, each with the same operational time structure.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"two_level = TwoLevel(2, simple)\nnper = length(two_level)","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"We can also define a strategic cost profile with different cost profiles for each strategic period.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"cost_strategic = StrategicProfile([FixedProfile(2.0), FixedProfile(3.0)])\nprint([cost_strategic[t] for t in two_level])","category":"page"},{"location":"tutorials/basic_usage/#Optimization-modeling","page":"Basic usage","title":"Optimization modeling","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"We are now ready to create a generic optimization model based on a given time structure and cost profile. This basic model illustrates the creation of optimization variables defined over the time structure, as well as constraints and an objective function based on the cost profile.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"function create_model_1(periods::TimeStructure, cost::TimeProfile)\n    m = Model()\n    @variable(m, x[periods])\n    @constraint(m, sum(x[t] for t in periods) <= 1)\n    @objective(m, Max, sum(cost[t] * x[t] for t in periods))\n    return m\nend","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"Using the simple time structure and fixed cost profile, we can create a first realization of the model.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"model = create_model_1(simple, cost_fixed)\nlatex_formulation(model)","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"Exchanging the fixed cost profile with the dynamic cost profile will change the model formulation to reflect the varying costs.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"model = create_model_1(simple, cost_dynamic)\nlatex_formulation(model)","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"Time profiles are not connected to the time structure, so we can use the same cost profile for different time structures. This allows for a flexible modeling approach, e.g., during testing and model development.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"simple_test = SimpleTimes([1])\nmodel = create_model_1(simple_test, cost_dynamic)\nlatex_formulation(model)","category":"page"},{"location":"tutorials/basic_usage/#Multiple-horizon-modeling","page":"Basic usage","title":"Multiple horizon modeling","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"In a multi horizon optimization problem, there are typically constraints that are defined for each strategic period separately. To illustrate this, we create a model with a separate constraint for each strategic period using the strat_periods function to iterate over the strategic periods of the time structure.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"function create_model_2(periods::TimeStructure, cost::TimeProfile)\n    m = Model()\n    @variable(m, x[periods])\n    for sp in strat_periods(periods)\n        @constraint(m, sum(x[t] for t in sp) <= 1)\n    end\n    @objective(m, Max, sum(cost[t] * x[t] for t in periods))\n\n    return m\nend","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"Creating a strategic model with a fixed cost profile, we see that we get a separate constraint for each of the two strategic periods.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"model = create_model_2(two_level, cost_fixed)\nlatex_formulation(model)","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"Using a strategic cost profile will differentiate the costs for each strategic period.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"model = create_model_2(two_level, cost_strategic)\nlatex_formulation(model)","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"A general design principle of the TimeStruct package is to allow for simpler time structures, even in models that have separate modeling, e.g. for strategic periods. This is illustrated here by using the simple time structure in the strategic model. In this case, iterating over the strategic periods will result in a single strategic period that is equal to the original time structure.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"model = create_model_2(simple, cost_fixed)\nlatex_formulation(model)","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic usage","title":"Basic usage","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contribute/#con","page":"Contribute","title":"Contribute to TimeStruct","text":"","category":"section"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"Contributing to TimeStruct can be achieved in several different ways.","category":"page"},{"location":"contribute/#con-bug_rep","page":"Contribute","title":"File a bug report","text":"","category":"section"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"One approach to contributing to TimeStruct is through filing a bug report as an issue when unexpected behaviour is occurring.","category":"page"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"When filing a bug report, please follow the following guidelines:","category":"page"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"be certain that the bug is a bug and originating in TimeStruct:\nIf the problem is within the results of your optimization problem, please be certain that your optimization model is correctly set up.\nIf the problem is only appearing for specific solvers, it is most likely not a bug in TimeStruct, but instead a problem of the solver wrapper for MathOptInterface. In this case, please contact the developers of the corresponding solver wrapper.\nlabel the issue as bug, and\nprovide a minimum working example of a case in which the bug occurs. This minimum working example should not be based on a potential application of TimeStruct. Instead, it is important to focus purely on how TimeStruct is behaving when the bug occurs.","category":"page"},{"location":"contribute/#con-feat_req","page":"Contribute","title":"Feature requests","text":"","category":"section"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"Although TimeStruct was designed with the aim of flexibility with respect to incorporation of different time structures, it sometimes still requires additional features. Feature requests can be achieved through two approaches:","category":"page"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"create an issue describing the aim of the feature request and\nincorporate the feature request through a fork of the repository and open a pull request.","category":"page"},{"location":"contribute/#con-feat_req-issue","page":"Contribute","title":"Create an Issue","text":"","category":"section"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"Creating a new issue for a feature request is our standard approach for contributing to TimeStruct. Due to the modularity of TimeStruct's individual time structures, it is not necessarily straight forward to understand how to best incorporate required features into the framework without breaking existing time structures.","category":"page"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"When creating a new issue as feature request, please follow the the following guidelines.","category":"page"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"Reason for the feature: Please describe the reasoning for the feature request. What functionality do you require in TimeStruct?\nRequired outcome: What should be the outcome when including the feature and what should be the minimum requirements of the outcome?\nPotential solutions: Describe alternatives you consider. This step is not necessarily required, but can be helpful for identifying potential solutions.","category":"page"},{"location":"contribute/#con-feat_req-fork","page":"Contribute","title":"Incorporating the feature requests through a fork","text":"","category":"section"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"note: Note\nThe approach used for providing code is based on the excellent description of the JuMP package. We essentially follow the same approach with minor changes.","category":"page"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"If you would like to work directly in TimeStruct, you can also incorporate your changes directly. In this case, it is beneficial to follow the outlined steps:","category":"page"},{"location":"contribute/#con-feat_req-fork-step_1","page":"Contribute","title":"Step 1: Create an issue","text":"","category":"section"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"Even if you plan to incorporate the code directly, we advise you to first follow the steps outlined in Create an Issue. This way, it is possible for us to comment on the solution approach(es) and assess potential problems with other time structures.","category":"page"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"Through creating an issue first, it is possible for us to comment directly on the proposed changes and assess, whether we consider the proposed changes to follow the philosophy of the framework.","category":"page"},{"location":"contribute/#con-feat_req-fork-step_2","page":"Contribute","title":"Step 2: Create a fork of TimeStruct","text":"","category":"section"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"Contributing code to TimeStruct should follow the standard approach by creating a fork of the repository. All work on the code should occur within the fork.","category":"page"},{"location":"contribute/#con-feat_req-fork-step_3","page":"Contribute","title":"Step 3: Checkout a new branch in your local fork","text":"","category":"section"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"It is in general preferable to work on a separate branch when developing new components.","category":"page"},{"location":"contribute/#con-feat_req-fork-step_4","page":"Contribute","title":"Step 4: Make changes to the code base","text":"","category":"section"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"Incorporate your changes in your new branch. The changes should be commented to understand the thought process behind them. In addition, please provide new tests for the added functionality and be certain that the existing tests run. New tests should be based on a minimum working example in which the new concept is evaluated.","category":"page"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"tip: Tip\nIt is in our experience easiest to use the package TestEnv for testing the complete package.","category":"page"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"Aside from the individual tests, it is required to use JuliaFormatter on the code.","category":"page"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"It is not necessary to provide changes directly in the documentation. It can be easier to include these changes after the pull request is accepted in principal.","category":"page"},{"location":"contribute/#con-feat_req-fork-step_5","page":"Contribute","title":"Step 5: Create a pull request","text":"","category":"section"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"Once you are satisfied with your changes, create a pull request towards the main branch of the TimeStruct repository. We will internally assign the relevant person to the pull request.","category":"page"},{"location":"contribute/","page":"Contribute","title":"Contribute","text":"You may receive quite a few comments with respect to the incorporation and how it may potentially affect other parts of the code. Please remain patient as it may take potentially some time before we can respond to the changes, although we try to answer as fast as possible.","category":"page"},{"location":"manual/discount/#man-disc","page":"Discounting","title":"Discounting","text":"","category":"section"},{"location":"manual/discount/","page":"Discounting","title":"Discounting","text":"For multi-year investment optimization models it is common practice to use an objective that is discounted to get the net present value of the investment. Since investment decisions usually are done on a strategic level, discount factors are also calculated based on strategic periods.","category":"page"},{"location":"manual/discount/","page":"Discounting","title":"Discounting","text":"The discount factor for a time period t is found by the discount function. There are two strategies for calculating the discount factor, either all discounting is calculated based on the start of the strategic period or it is based on finding an approximation of the average value over the strategic period. The following example shows how these two types will differ for a planning period of 50 years, consisting of 5 periods of 10 years:","category":"page"},{"location":"manual/discount/","page":"Discounting","title":"Discounting","text":"using TimeStruct\nts = TwoLevel(5, 10, SimpleTimes(1,1));\ndf_start = [discount(t, ts, 0.05; type = \"start\") for t in ts]\ndf_avg = [discount(t, ts, 0.05; type = \"avg\") for t in ts]","category":"page"},{"location":"manual/discount/","page":"Discounting","title":"Discounting","text":"While it is often normal to assume investments at the start of each strategic period, it can be more correct to average the discount factor for operational costs that are accrued throughout the strategic period.","category":"page"},{"location":"manual/discount/","page":"Discounting","title":"Discounting","text":"To help setting up the objective function in a typical optimization problem, there is a utility function objective_weight that returns the weight to give a time period in the objective, considering both discount factor, probability and possible multiplicity.","category":"page"},{"location":"manual/iteration/#man-iter","page":"Iteration utilities","title":"Iteration utilities","text":"","category":"section"},{"location":"manual/iteration/#man-iter-basic","page":"Iteration utilities","title":"Basic iteration","text":"","category":"section"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"All time structures are iterable over their operational time periods","category":"page"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"using TimeStruct\n\nfunction iterate_ex(periods::TimeStructure)\n    for t in periods\n        println(t)\n    end\nend","category":"page"},{"location":"manual/iteration/#man-iter-prev","page":"Iteration utilities","title":"Iteration with previous","text":"","category":"section"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"In many settings, e.g. tracking of storage, it is convenient to have access to the previous time period. By using the custom iterator withprev it is possible to return both the previous and current time period as a tuple when iterating:","category":"page"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"using TimeStruct\nperiods = SimpleTimes(5, 1);\ncollect(withprev(periods))","category":"page"},{"location":"manual/iteration/#man-iter-chunk","page":"Iteration utilities","title":"Iteration with chunks of time periods","text":"","category":"section"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"Sometimes it is convenient to iterate through the time periods as chunks of a fixed number of periods or minimum duration, e.g. in production planning with minimum production runs. To simplify this process there are several iterator wrappers that allows this kind of iteration pattern.","category":"page"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"The chunk function iterates through a time structure returning subsequences of length at most n starting at each time period.","category":"page"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"periods = SimpleTimes(5,1)\ncollect(collect(ts) for ts in chunk(periods, 3))","category":"page"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"This wrapper can be used for e.g. modelling of startup modelling with a minimum uptime. The following example shows how this can be implemented as part of a JuMP model:","category":"page"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"using JuMP, TimeStruct\n\nperiods = SimpleTimes(5,1)\n\nm = Model()\n@variable(m, startup[periods], Bin)\n@variable(m, shutdown[periods], Bin)\n\nfor ts in chunk(periods, 3)\n    @constraint(m, sum(shutdown[t] for t in ts) <= 3 * (1 - startup[first(ts)]))\nend\n\nfor cref in all_constraints(m, AffExpr, MOI.LessThan{Float64}) # hide\n    println(constraint_string(MIME(\"text/plain\"), cref; in_math_mode = true)) # hide\nend # hide","category":"page"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"Similarly, if modelling startup decisions with a minimum downtime, it is possible to reverse the original time periods and then chunk:","category":"page"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"using JuMP, TimeStruct # hide\nperiods = SimpleTimes(5,1) # hide\n\nm = Model() # hide\n@variable(m, startup[periods], Bin) # hide\n@variable(m, shutdown[periods], Bin) # hide\nfor ts in chunk(Iterators.reverse(periods), 3)\n    @constraint(m, sum(shutdown[t] for t in ts) <= 3 * (1 - startup[first(ts)]))\nend\n\nfor cref in all_constraints(m, AffExpr, MOI.LessThan{Float64}) # hide\n    println(constraint_string(MIME(\"text/plain\"), cref; in_math_mode = true)) # hide\nend # hide","category":"page"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"It is also possible to get cyclic behaviour by setting the cyclic argument to true. If reaching the end before the required number of time periods, the chunk will continue from the first time period.","category":"page"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"using JuMP, TimeStruct # hide\nperiods = SimpleTimes(5,1) # hide\n\nm = Model() # hide\n@variable(m, startup[periods], Bin) # hide\n@variable(m, shutdown[periods], Bin) # hide\nfor ts in chunk(periods, 3; cyclic = true)\n    @constraint(m, sum(shutdown[t] for t in ts) <= 3 * (1 - startup[first(ts)]))\nend\nfor cref in all_constraints(m, AffExpr, MOI.LessThan{Float64}) # hide\n    println(constraint_string(MIME(\"text/plain\"), cref; in_math_mode = true)) # hide\nend # hide","category":"page"},{"location":"manual/iteration/#man-iter-chunk_dur","page":"Iteration utilities","title":"Chunks based on duration","text":"","category":"section"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"If working with a time structure that has varying duration for its time periods, it can be more convenient with chunks based on their combined duration.","category":"page"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"The chunk_duration function iterates through a time structure returning subsequences of duration at least dur starting at each time period.","category":"page"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"periods = SimpleTimes(5,[1, 2, 1, 1.5, 0.5, 2])\ncollect(collect(ts) for ts in chunk_duration(periods, 3))","category":"page"},{"location":"manual/iteration/#man-iter-index","page":"Iteration utilities","title":"Indexing of operational time structures","text":"","category":"section"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"It is possible to use indices for operational time structures, either directly using SimpleTimes or CalendarTimes or by accessing an operational scenario.","category":"page"},{"location":"manual/iteration/","page":"Iteration utilities","title":"Iteration utilities","text":"periods = TwoLevel(3, 100, SimpleTimes(10,1));\n\nscenario = first(opscenarios(periods))\nscenario[3]","category":"page"},{"location":"manual/basic/#man-oper","page":"Operational time structures","title":"Operational time structures","text":"","category":"section"},{"location":"manual/basic/#man-oper-simple","page":"Operational time structures","title":"SimpleTimes","text":"","category":"section"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"The basic time structure is SimpleTimes which represents a continuous period of time divided into individual time periods of varying duration. The length of each time period is obtained by the duration(t) function.","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"periods = SimpleTimes(5, [1, 1, 1, 5, 5]);\ndurations = [duration(t) for t in periods]","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"(Image: Illustration of SimpleTimes)","category":"page"},{"location":"manual/basic/#man-oper-calendar","page":"Operational time structures","title":"Calendar based","text":"","category":"section"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"For some applications it is required to relate the time periods to actual calendar dates. This is supported by the time structure CalendarTimes that allows for creation and iteration of a calendar based sequence of periods in combination with calendar arithmetic.","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"The following example shows the creation of a time structure with 12 months starting from the first of January 2024. The duration of each time period is given in hours by default, but it is possible to specify the time units to use by providing the period type to use:","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"using Dates\nyear = CalendarTimes(DateTime(2024, 1, 1), 12, Month(1));\nduration(first(year); dfunc = Dates.Day)","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"You can also make the time structure for a specific time zone as shown in the following example with 3 days in the end of March with a transition to summer time on the second day:","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"using TimeZones\nperiods = CalendarTimes(DateTime(2023, 3, 25), tz\"Europe/Berlin\", 3, Day(1));\nduration.(periods)","category":"page"},{"location":"manual/basic/#man-oper-osc","page":"Operational time structures","title":"Operational scenarios","text":"","category":"section"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"Operations often face uncertain operating conditions. In energy systems modeling, a typical example is the availability of wind and solar power. One method for accounting for this uncertainty is to have multiple operational scenarios that are used to evaluate the cost and feasibility of operations, where each scenario has a given probability of occurring.","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"The time structure OperationalScenarios represents an unordered collection of operational scenarios where each scenario has a separate time structure and an associated probability.","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"using TimeStruct, JuMP\nscenarios = OperationalScenarios(\n    3,\n    [SimpleTimes(5,1), SimpleTimes(7,2), SimpleTimes(10,1)],\n    [0.3, 0.2, 0.5]\n);","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"(Image: Illustration of OperationalScenarios)","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"Similar to representative periods, each period has a multiple that is defined relative to the maximum duration for all scenarios. In addition, each time period has a probabilityequal to the probability of its scenario. Thus we have that:","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"sum(duration(t) * probability(t) * multiple(t) for t in scenarios)","category":"page"},{"location":"manual/basic/#man-oper-repr","page":"Operational time structures","title":"Representative periods","text":"","category":"section"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"In some cases, a fine-scale representation for the operations of the infrastructure of the whole time horizon, is not feasible. A possible strategy is then to select one or more representative periods and use them to evaluate operational cost and feasibility. The time structure  RepresentativePeriods consists of an ordered sequence of representative periods that represents a longer period of time. Each representative period covers a specified share of the whole time period.","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"The following example shows an example with a year with daily resolution represented by two weeks with a share of 0.7 and 0.3 respectively.","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"using JuMP, TimeStruct\n\nperiods = RepresentativePeriods(\n    2,\n    365,\n    [0.7, 0.3],\n    [SimpleTimes(7,1), SimpleTimes(7,1)]\n);","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"The time periods can be iterated both for the whole time structure and individually by each representative period using the repr_periods function. This is illustrated here when setting up a JuMP model with a separate constraint for each representative period:","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"m = Model();\n@variable(m, prod[periods] >= 0);\n\nfor rp in repr_periods(periods)\n    @constraint(m, sum(prod[t] for t in rp) <= 10)\nend\n\n@constraint(m, sum(prod[t] * multiple(t) for t in periods) <= 1);","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"For each time period the multiple function returns how many times the given period should be counted when aggregating to the whole RepresentativePeriods structure. This will take into account both the duration and share of each representative period, thus we have that:","category":"page"},{"location":"manual/basic/","page":"Operational time structures","title":"Operational time structures","text":"sum(duration(t) * multiple(t) for t in periods)","category":"page"},{"location":"manual/multi/#man-multi","page":"Multi-horizon","title":"Multi-horizon time structures","text":"","category":"section"},{"location":"manual/multi/#man-multi-twolevel","page":"Multi-horizon","title":"TwoLevel structure","text":"","category":"section"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"The main motivation for the TimeStruct package is to support multi-horizon optimization models. The time structure TwoLevel allows for a two level approach, combining an ordered sequence of strategic periods with given duration and an associated operational time structure.","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"using TimeStruct\nperiods = TwoLevel(\n    [SimpleTimes(5,1), SimpleTimes(5,1), SimpleTimes(5,1)],\n);","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"(Image: Illustration of TwoLevel)","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"The following example shows a typical usage of a TwoLevel structure with investment decisions on a strategic level and operational decision variables. It is possible to iterate through each strategic period using the strat_periodsfunction.","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"using JuMP\nm = Model();\n@variable(m, invest[strat_periods(periods)] >= 0);\n@variable(m, prod[periods] >= 0);\n\nfor sp in strat_periods(periods)\n    @constraint(m, sum(prod[t] for t in sp) <= invest[sp])\nend","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"It is also possible to combine a TwoLevel time structure with more complex operational structures like RepresentativePeriods and OperationalScenarios, alone or in combination, as shown in the following example and illustrated the figure below.","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"oper = SimpleTimes(5,1);\nscen = OperationalScenarios([oper, oper, oper], [0.4, 0.5, 0.1]);\nrepr = RepresentativePeriods(2, 5, [0.5, 0.5], [oper, oper]);\nrepr_scen = RepresentativePeriods(2, 5, [0.5, 0.5], [scen, scen]);\n\nperiods = TwoLevel([scen, repr, repr_scen]);","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"(Image: Complex TwoLevel)","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"In the above examples, the duration of the operational time structures have been equal to the duration of the strategic periods, but this is not required. If the duration of the operational time structure is shorter than the strategic period, this will be accounted for with the multiple function.","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"It is also sometimes convenient to use a different time unit for the strategic periods than the operational time periods. This is controlled by the op_per_strat field of the TwoLevel structure that holds the number of operational periods per strategic period.","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"A typical use case is an investment problem where one uses years to measure duration at the strategic level and hours/days on the operational level. Below is an example with 3 strategic periods of duration 5, 5, and 10 years respectively, while the operational time structure is given by representative periods with duration in days. The op_per_strat is then set to 365.","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"week = SimpleTimes(7,1);\nrepr = RepresentativePeriods(2, 365, [0.6, 0.4], [week, week]);\nperiods = TwoLevel(3, [5, 5, 10], [repr, repr, repr], 365.0);","category":"page"},{"location":"manual/multi/#man-multi-twoleveltree","page":"Multi-horizon","title":"TwoLevelTree structure","text":"","category":"section"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"If there is uncertainty at a strategic level, this can be incorporated using the TwoLevelTree time structure. This structure is represented by a tree, with each node corresponding to a strategic period that contains an operational time structure. The operational time structure can be any combination of the described structures.","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"The following example demonstrates how to create a regular tree  (through the function regular_tree) where each strategic period spans 3 years and is represented by a week with daily resolution. The second  argument to the regular_tree function specifies the number of branches at each stage of the tree, excluding the first stage.","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"using TimeStruct\noperational = SimpleTimes(7, 1);\ntwo_level_tree = regular_tree(3, [3,2], operational; op_per_strat = 52);","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"(Image: Illustration of TwoLevelTree)","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"The branching probabilities are equal for all branches as indicated in green in the figure.","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"note: Constructors for TwoLevelTree\nCurrently, the functionality for creating  TwoLevelTree's is limited. Future versions of the package will expand this functionality to allow creating trees with varying probabilities and different operational time structures for the nodes.","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"Similar as for TwoLevel, the strategic nodes can be iterated using strat_periods. It is possible to connect the nodes to their predecessor by iterating using the withprev iterator that returns a tuple with the parent or nothing if no parent, together with the node itself. This provides the flexibility to track decisions in the tree as shown by the following example that allows investment into new capacity in each strategic node while tracking the accumulated capacity.","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"using JuMP\n\nm = Model();\nstrat_pers = strat_periods(two_level_tree);\n@variable(m, invest[strat_pers], Bin);\n@variable(m, cap[strat_pers] >= 0);\nfor (prev, sp) in withprev(strat_pers)\n    if !isnothing(prev)\n        @constraint(m, cap[sp] == cap[prev] + 10 * invest[prev])\n    end\nend","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"To ensure consistency across the tree, it is possible to iterate through all strategic scenarios in the tree using strategic_scenarios. Here each scenario is a path from the root node to one of the leaves of the tree. In the example above, if we only allow one investment in the planning period, this can be added by restricting the number of investments in each scenario:","category":"page"},{"location":"manual/multi/","page":"Multi-horizon","title":"Multi-horizon","text":"for sc in strategic_scenarios(two_level_tree)\n    @constraint(m, sum(invest[sp] for sp in sc) <= 1)\nend","category":"page"},{"location":"tutorials/battery_sizing/#Battery-sizing","page":"Battery sizing","title":"Battery sizing","text":"","category":"section"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"This tutorial demonstrates how to formulate a battery sizing problem using the TimeStruct package in combination with JuMP. We start by defining the operational model of the battery, which includes the constraints and the objective function. Then, we extend the model to include the strategic decisions of the battery sizing.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"For this tutorial, we use the HiGHS solver for optimization:","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"using TimeStruct\nusing JuMP\nusing HiGHS\n\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false)","category":"page"},{"location":"tutorials/battery_sizing/#Operational-model","page":"Battery sizing","title":"Operational model","text":"","category":"section"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"We start by defining the operational model of the battery. The battery has a fixed capacity and can charge and discharge energy to cover a given demand profile. Additionally, the demand can be covered by purchasing energy from the spot market with a given price profile.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"function create_operational(\n    periods::TimeStructure,\n    capacity,\n    demand::TimeProfile,\n    price::TimeProfile,\n)\n    model = Model()\n\n    @variable(model, soc[periods] >= 0)         # State of charge of the battery\n    @variable(model, charge[periods] >= 0)      # Energy charged to the battery\n    @variable(model, discharge[periods] >= 0)   # Energy discharged from the battery\n    @variable(model, spot[periods] >= 0)        # Energy purchased from the spot market\n\n    for (prev, t) in withprev(periods)\n        @constraint(model, soc[t] <= capacity)\n        soc_prev = isnothing(prev) ? soc[last(periods)] : soc[prev]\n        @constraint(model, soc[t] == soc_prev + charge[t] - discharge[t])\n        @constraint(model, spot[t] + discharge[t] - charge[t] == demand[t])\n    end\n\n    @objective(model, Min, sum(multiple(t) * price[t] * spot[t] for t in periods))\n    return model\nend","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"Note the use of the special iterator  withprev to iterate over the periods with the previous period, returning nothing for the first period. In this example we have opted to use a cyclic constraint for the state of charge, i.e. the state of charge of the last period is used as the initial state of charge for the first period.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"To test the model, we create a simple example with 24 hourly periods, a capacity of 20, a fixed demand of 5.0, and a time dependent price profile that varies sinusoidally over a day.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"periods = SimpleTimes(24, 1)\ncapacity = 20\ndemand = FixedProfile(5.0)\nprice = OperationalProfile([1 + 0.3 * sin(i) for (i, t) in enumerate(periods)])\n\nmodel = create_operational(periods, capacity, demand, price)\nset_optimizer(model, optimizer)\noptimize!(model)\nprintln(\"Objective value: \", objective_value(model))","category":"page"},{"location":"tutorials/battery_sizing/#Strategic-model","page":"Battery sizing","title":"Strategic model","text":"","category":"section"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"We now extend the operational model to include the strategic decisions of the battery sizing. For simplicity, we assume that the battery capacity can be chosen independently for each stragic period, e.g., by renting a battery of a given capacity for each strategic period.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"To simplify the process of defining the strategic model, we define helper functions to create the operational variables, constraints, and objective function.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"function create_operational_variables(model, periods)\n    @variable(model, soc[periods] >= 0)\n    @variable(model, charge[periods] >= 0)\n    @variable(model, discharge[periods] >= 0)\n    @variable(model, spot[periods] >= 0)\nend\n\nfunction create_operational_constraints(model, periods, capacity, demand)\n    soc, charge, discharge = model[:soc], model[:charge], model[:discharge]\n    spot = model[:spot]\n    for (prev, t) in withprev(periods)\n        @constraint(model, soc[t] <= capacity)\n        soc_prev = isnothing(prev) ? soc[last(periods)] : soc[prev]\n        @constraint(model, soc[t] == soc_prev + charge[t] - discharge[t])\n        @constraint(model, spot[t] + discharge[t] - charge[t] == demand[t])\n    end\nend\n\nfunction create_operational_objective(model, periods, price)\n    spot = model[:spot]\n    el_cost = sum(multiple(t) * probability(t) * price[t] * spot[t] for t in periods)\n    return el_cost\nend","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"Note the use of the multiple function to include the multiplier of each operational period for time structures where the operational periods do not cover the complete strategic periods and probability for periods that have an associated probability when using operational scenarios.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"We can now define the strategic model by creating a battery sizing decision for each strategic period. To obtain the strategic periods, we use the strat_periods iterator.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"function create_strategic_model(\n    periods::TimeStructure,\n    price::TimeProfile,\n    demand::TimeProfile,\n    capex,\n)\n    model = Model()\n    @variable(model, cap[strat_periods(periods)] >= 0)\n\n    create_operational_variables(model, periods)\n    for sp in strat_periods(periods)\n        create_operational_constraints(model, sp, cap[sp], demand)\n    end\n    op_cost = create_operational_objective(model, periods, price)\n    investment_cost = sum(cap[sp] * capex[sp] for sp in strat_periods(periods))\n    @objective(model, Min, investment_cost + op_cost)\n    return model\nend","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"Note that each strategic period can be iterated as a separate time structure and be used to define the operational constraints.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"To test the model, we create a simple example with 7 strategic periods of 24 hourly periods each","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"periods = TwoLevel(7, SimpleTimes(24, 1))\ndemand = StrategicProfile([5.0 + 0.5 * i for i in 1:7])\nprice = OperationalProfile([1 + 0.3 * sin(i) for i in 1:24])\ncapex = StrategicProfile([2 - 0.1 * i for i in 1:7])\n\nmodel = create_strategic_model(periods, price, demand, capex)\n\nset_optimizer(model, optimizer)\noptimize!(model)\nprintln(\"Objective value: \", objective_value(model))\nprintln(\"Battery sizing: \", [value(model[:cap][sp]) for sp in strat_periods(periods)])","category":"page"},{"location":"tutorials/battery_sizing/#Representative-periods","page":"Battery sizing","title":"Representative periods","text":"","category":"section"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"In large scale models, it is common to use representative periods to reduce the computational burden by aggregating the time series involved and use these to represent a larger share of the planning period. With TimeStruct, we can create constraints separately for each representative period by using the repr_periods iterator.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"function create_strat_repr_model(periods, price, demand, capex)\n    model = Model()\n    @variable(model, cap[strat_periods(periods)] >= 0)\n\n    create_operational_variables(model, periods)\n    for sp in strat_periods(periods)\n        for rp in repr_periods(sp)\n            create_operational_constraints(model, rp, cap[sp], demand)\n        end\n    end\n\n    op_cost = create_operational_objective(model, periods, price)\n    investment_cost = sum(cap[sp] * capex[sp] for sp in strat_periods(periods))\n    @objective(model, Min, investment_cost + op_cost)\n    return model\nend","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"Setting up the model with representative periods requires defining the representative periods and the representative price profile.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"periods = TwoLevel(\n    5,\n    1,\n    RepresentativePeriods(8760, [0.3, 0.2, 0.4, 0.1], SimpleTimes(24, 1));\n    op_per_strat = 8760,\n)\nrepr_price = RepresentativeProfile([0.9 * price, 1.1 * price, 0.8 * price, 1.2 * price])","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"In this example, we use 5 strategic periods of length 1 year each. Each strategic period is represented by 4 representative periods of 24 hours each. Note the use of the parameter op_per_strat to define the number of operational periods per strategic period.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"model = create_strat_repr_model(periods, repr_price, demand, capex)\nset_optimizer(model, optimizer)\noptimize!(model)\nprintln(\"Objective value: \", objective_value(model))\nprintln(\"Battery sizing: \", [value(model[:cap][sp]) for sp in strat_periods(periods)])","category":"page"},{"location":"tutorials/battery_sizing/#Operational-scenarios","page":"Battery sizing","title":"Operational scenarios","text":"","category":"section"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"Finally, we can extend the model to include operational scenarios to account for operational uncertainty in the battery sizing problem. Typically, the spot prices are uncertain and can be modeled as a set of scenarios with a specified probability for each scenario.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"function create_strat_repr_scen_model(periods, price, demand, capex)\n    model = Model()\n    @variable(model, cap[strat_periods(periods)] >= 0)\n\n    create_operational_variables(model, periods)\n    for sp in strat_periods(periods)\n        for rp in repr_periods(sp)\n            for sc in opscenarios(rp)\n                create_operational_constraints(model, sc, cap[sp], demand)\n            end\n        end\n    end\n    op_cost = create_operational_objective(model, periods, price)\n    investment_cost = sum(cap[sp] * capex[sp] for sp in strat_periods(periods))\n    @objective(model, Min, investment_cost + op_cost)\n    return model\nend","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"The only difference in the model is the use of the opscenarios iterator to iterate over the operational scenarios.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"The time structure is similar to the previous example, but we now include 10 operational scenarios for each representative period.","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"periods = TwoLevel(\n    5,\n    1,\n    RepresentativePeriods(\n        8760,\n        [0.3, 0.2, 0.4, 0.1],\n        OperationalScenarios(10, SimpleTimes(24, 1)),\n    );\n    op_per_strat = 8760,\n)\n\nprice = RepresentativeProfile([\n    0.9 * ScenarioProfile([price + 0.1 * rand() for sc in 1:10]),\n    1.1 * ScenarioProfile([price + 0.2 * rand() for sc in 1:10]),\n    0.8 * ScenarioProfile([price + 0.05 * rand() for sc in 1:10]),\n    1.2 * ScenarioProfile([price + 0.08 * rand() for sc in 1:10]),\n])\n\nmodel = create_strat_repr_scen_model(periods, price, demand, capex)\nset_optimizer(model, optimizer)\noptimize!(model)\nprintln(\"Objective value: \", objective_value(model))\nprintln(\"Battery sizing: \", [value(model[:cap][sp]) for sp in strat_periods(periods)])","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"","category":"page"},{"location":"tutorials/battery_sizing/","page":"Battery sizing","title":"Battery sizing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/api/#api-ts","page":"API reference","title":"Available time structures","text":"","category":"section"},{"location":"reference/api/#TimeStruct.TimeStructure","page":"API reference","title":"TimeStruct.TimeStructure","text":"abstract type TimeStructure{T<:Duration}\n\nAbstract type representing different time structures that consists of one or more time periods.\n\nThe type 'T' gives the data type used for the duration of the time periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.SimpleTimes","page":"API reference","title":"TimeStruct.SimpleTimes","text":"struct SimpleTimes{T} <: TimeStructure{T}\n\nSimpleTimes(len::Integer, duration::Vector{T}) where {T<:Duration}\nSimpleTimes(len::Integer, duration::Duration)\nSimpleTimes(dur::Vector{T}) where {T<:Duration}\n\nA simple time structure consisting of consecutive time periods of varying duration. SimpleTimes is always the lowest level in a TimeStruct time structure. if used.\n\nAn alternative for SimpleTimes is CalendarTimes\n\nExample\n\nuniform = SimpleTimes(5, 1.0) # 5 periods of equal length\nvarying = SimpleTimes([2, 2, 2, 4, 10]) # 5 periods of varying length\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.CalendarTimes","page":"API reference","title":"TimeStruct.CalendarTimes","text":"struct CalendarTimes{T} <: TimeStructure{T}\n\nCalendarTimes(start_date, length, period)\nCalendarTimes(start_date, end_date, period)\nCalendarTimes(start_date, timezone, length, period)\nCalendarTimes(start_date, end_date, timezone, period)\n\nA time structure that iterates flexible calendar periods using calendar arithmetic. This time structure can be used at the lowest level of time structures similar to SimpleTimes.\n\nExample\n\nts = CalendarTimes(Dates.DateTime(2023, 1, 1), 12, Dates.Month(1))\nts_zoned = CalendarTimes(Dates.DateTime(2023, 1, 1), tz\"Europe/Berlin\", 52, Dates.Week(1))\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.RepresentativePeriods","page":"API reference","title":"TimeStruct.RepresentativePeriods","text":"struct RepresentativePeriods{S<:Duration,T,OP<:TimeStructure{T}} <: TimeStructure{T}\n\nRepresentativePeriods(len::Integer, duration::S, period_share::Vector{<:Real}, rep_periods::Vector{OP}) where {S<:Duration, T, OP<:TimeStructure{T}}\nRepresentativePeriods(len::Integer, duration::S, rep_periods::TimeStructure{T}) where {S<:Duration, T}\n\nRepresentativePeriods(duration::S, period_share::Vector{<:Real}, rep_periods::Vector{<:TimeStructure{T}}) where {S<:Duration, T}\nRepresentativePeriods(duration::S, period_share::Vector{<:Real}, rep_periods::TimeStructure{T}) where {S<:Duration, T}\n\nRepresentativePeriods(duration::S, rep_periods::Vector{<:TimeStructure{T}}) where {S<:Duration, T}\n\nTime structure that allows a time period to be represented by one or more shorter representative time periods.\n\nThe representative periods are an ordered sequence of TimeStructures that are used for each representative period. In addition, each representative period has an associated share that specifies how much of the total duration that is attributed to it.\n\nnote: Note\nAll representative periods must use the same type for the TimeStructure.\nIf the field period_share is not specified, it assigns the same probability to each representative period.\nIt is possible that sum(period_share) is larger or smaller than 1. This can lead to problems in your application. Hence, it is advised to scale it. Currently, a warning will be given if the period shares do not sum to one as an automatic scaling will correspond to a breaking change.\nIf you include OperationalScenarios in your time structure, it is important that the scenarios are within the representative periods, and not the other way.\n\nExample\n\n# A year represented by two days with hourly resolution and relative shares of 0.7 and 0.3\nRepresentativePeriods(8760, [0.7, 0.3], [SimpleTimes(24, 1), SimpleTimes(24,1)])\nRepresentativePeriods(8760, [0.7, 0.3], SimpleTimes(24, 1))\n\n# A year represented by two days with hourly resolution and relative shares of 0.5\nRepresentativePeriods(2, 8760, SimpleTimes(24, 1))\nRepresentativePeriods(8760, [SimpleTimes(24, 1), SimpleTimes(24,1)])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.OperationalScenarios","page":"API reference","title":"TimeStruct.OperationalScenarios","text":"struct OperationalScenarios{T,OP<:TimeStructure{T}} <: TimeStructure{T}\n\nOperationalScenarios(len::Integer, scenarios::Vector{OP}, probability::Vector{<:Real}) where {T, OP<:TimeStructure{T}\nOperationalScenarios(len::Integer, oper::TimeStructure{T})\n\nOperationalScenarios(oper::Vector{<:TimeStructure{T}}, prob::Vector)\nOperationalScenarios(oper::Vector{<:TimeStructure{T}})\n\nTime structure that have multiple scenarios where each scenario has its own time structure and an associated probability. These scenarios are in general represented as SimpleTimes.\n\nnote: Note\nAll scenarios must use the same type for the duration, .i.e., either Integer or Float.\nIf the probability is not specified, it assigns the same probability to each scenario.\nIt is possible that sum(probability) is larger or smaller than 1. This can lead to problems in your application. Hence, it is advised to scale it. Currently, a warning will be given if the period shares do not sum to one as an automatic scaling will correspond to a breaking change.\n\nExample\n\nThe following examples create a time structure with 2 operational scenarios corresponding to a single day with equal probability.\n\nday = SimpleTimes(24, 1)\nOperationalScenarios(2, day)\nOperationalScenarios([day, day], [0.5, 0.5])\nOperationalScenarios([day, day])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.TwoLevel","page":"API reference","title":"TimeStruct.TwoLevel","text":"struct TwoLevel{S<:Duration,T,OP<:TimeStructure{T}} <: TimeStructure{T}\n\nTwoLevel(len::Integer, duration::Vector{S}, operational::Vector{OP}, op_per_strat::Float64) where {S<:Duration, T, OP<:TimeStructure{T}}\nTwoLevel(len::Integer, duration::S, oper::TimeStructure{T}; op_per_strat) where {S, T}\nTwoLevel(len::Integer, oper::TimeStructure{T}; op_per_strat) where {T}\n\nTwoLevel(duration::S, oper::Vector{OP}; op_per_strat) where {S, T, OP<:TimeStructure{T}}\nTwoLevel(duration::Vector{S}, oper::TimeStructure{T}; op_per_strat) where {S, T}\n\nTwoLevel(oper::Vector{<:TimeStructure{T}}; op_per_strat) where [T]\n\nA time structure with two levels of time periods.\n\nOn the top level it has a sequence of strategic periods of varying duration. For each strategic period a separate time structure is used for operational decisions. Iterating the structure will go through all operational periods. It is possible to use different time units for the two levels by providing the number of operational time units per strategic time unit through the kewyord argument op_per_strat.\n\nPotential time structures are SimpleTimes, CalendarTimes, OperationalScenarios, or RepresentativePeriods, as well as combinations of these.\n\ndanger: Usage of op_per_strat\nThe optional keyword op_per_strat is important for the overall calculations. If you use an hourly resolution for your operational period and yearly for investment periods, then you have to specify it as op_per_strat = 8760.0. Not specifying it would imply that you use the same unit for strategic and operational periods.\n\nnote: Not specifying the duration\nIf you do not specify the field duration, then it is calculated given the function_total_duration(op) / op_per_strat for op in operin which oper::Vector{<:TimeStructure{T}. The internal function _total_duration corresponds in this case to the sum of the duration of all operational periods divided by the value of the field op_per_strat.\n\nExample\n\n# 5 years with 24 hours of operations for each year. Note that in this case we use as unit\n# `hour` for both the duration of strategic periods and operational periods\nTwoLevel(5, 8760, SimpleTimes(24, 1))\n\n# The same time structure with the unit `year` for strategic periods and unit `hour` for\n# operational periods\nTwoLevel(5, 1, SimpleTimes(24, 1); op_per_strat=8760.0)\n\n# All individual constructors\nTwoLevel(2, ones(2), [SimpleTimes(24, 1), SimpleTimes(24, 1)], op_per_strat=8760.0)\nTwoLevel(2, 1, SimpleTimes(24, 1); op_per_strat=8760.0)\nTwoLevel(1, [SimpleTimes(24, 1), SimpleTimes(24, 1)]; op_per_strat=8760.0)\nTwoLevel(ones(2), SimpleTimes(24, 1); op_per_strat=8760.0)\n\n# Constructors without duration\nTwoLevel([SimpleTimes(24, 1), SimpleTimes(24, 1)]; op_per_strat=8760.0)\nTwoLevel(2, SimpleTimes(24, 1); op_per_strat=8760.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.TwoLevelTree","page":"API reference","title":"TimeStruct.TwoLevelTree","text":"mutable struct TwoLevelTree{S,T,OP<:AbstractTreeNode{S,T}} <: TimeStructure{T}\n\nTime structure allowing for a tree structure for the strategic level.\n\nFor each strategic node in the tree a separate time structure is used for operational decisions. Iterating the structure will go through all operational periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.regular_tree","page":"API reference","title":"TimeStruct.regular_tree","text":"regular_tree(\n    duration::S,\n    branching::Vector,\n    ts::OP;\n    op_per_strat::Real=1.0,\n) where {S, T, OP<:TimeStructure{T}}\n\nFunction for creating a regular tree with a uniform structure for each strategic period. Each strategic period is of equal length as given by duration and will have the same operational time structure ts. The vector branching specifies the number of branchings at each stage of the tree, excluding the first stage. The branches at each stage will all have equal probability.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#api-prop_ts","page":"API reference","title":"Properties of time structures","text":"","category":"section"},{"location":"reference/api/#TimeStruct.mult_scen","page":"API reference","title":"TimeStruct.mult_scen","text":"mult_scen(scen)\n\nReturns the multiplication factor to be used for this scenario when comparing with the overall set of operational scenarios.\n\nIf all scenarios in a set of operational scenarios are of equal duration (preferred usage), this factor is equal to one. Otherwise this factor would be equal to the ratio of the scenario with longest duration to the duration of the given scenario.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.mult_repr","page":"API reference","title":"TimeStruct.mult_repr","text":"mult_repr(rp)\n\nReturns the multiplication factor to be used for this representative period when comparing with the representative periods structure it is part of.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.mult_strat","page":"API reference","title":"TimeStruct.mult_strat","text":"mult_strat(sp)\n\nReturns the multiplication factor to be used for this strategic period when comparing the duration of the strategic period to the duration of the time structure being used for the strategic period.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.probability_scen","page":"API reference","title":"TimeStruct.probability_scen","text":"probability_scen(scen)\n\nThe probability of a single scenario in a set of operational scenarios.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#api-iter","page":"API reference","title":"Iterating time structures","text":"","category":"section"},{"location":"reference/api/#TimeStruct.repr_periods","page":"API reference","title":"TimeStruct.repr_periods","text":"repr_periods(ts::TimeStructure)\n\nThis function returns a type for iterating through the individual representative periods of a TimeStructure. The type of the iterator is dependent on the type of the input TimeStructure.\n\nWhen the TimeStructure is a TimeStructure, repr_periods returns a SingleReprPeriodWrapper. This corresponds to the default behavior.\n\n\n\n\n\nWhen the TimeStructure is a RepresentativePeriods, repr_periods returns the iterator ReprPers.\n\n\n\n\n\nWhen the TimeStructure is a StrategicPeriod, repr_periods returns the iterator StratReprPers.\n\n\n\n\n\nWhen the TimeStructure is a SingleStrategicPeriod, repr_periods returns the correct behavior based on the substructure.\n\n\n\n\n\nWhen the TimeStructure is a TwoLevel, repr_periods returns an Array of all StratReprPeriods.\n\n\n\n\n\nWhen the TimeStructure is a StratNode, repr_periods returns the iterator StratNodeReprPers.\n\n\n\n\n\nWhen the TimeStructure is a TwoLevelTree, repr_periods returns an Array of all StratNodeReprPeriods.\n\nThese are equivalent to a StratReprPeriod of a TwoLevel time structure.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.opscenarios","page":"API reference","title":"TimeStruct.opscenarios","text":"opscenarios(ts::TimeStructure)\n\nThis function returns a type for iterating through the individual operational scenarios of a TimeStructure. The type of the iterator is dependent on the type of the input TimeStructure.\n\nWhen the TimeStructure is a TimeStructure, opscenarios returns a SingleScenarioWrapper. This corresponds to the default behavior.\n\n\n\n\n\nWhen the TimeStructure is an OperationalScenarios, opscenarios returns the iterator OpScens.\n\n\n\n\n\nWhen the TimeStructure is a RepresentativePeriod with OperationalScenarios, opscenarios returns the iterator RepOpScens.\n\n\n\n\n\nWhen the TimeStructure is a SingleReprPeriod, opscenarios returns the correct behavior based on the substructure.\n\n\n\n\n\nWhen the TimeStructure is a RepresentativePeriods, opscenarios returns an Array of all ReprOpScenarios.\n\n\n\n\n\nWhen the TimeStructure is a StrategicPeriod, opscenarios returns the iterator StratOpScens.\n\n\n\n\n\nWhen the TimeStructure is a StrategicPeriod with RepresentativePeriods, opscenarios returns a vector of StratReprOpScenarios.\n\n\n\n\n\nWhen the TimeStructure is a SingleStrategicPeriod, opscenarios returns the correct behavior based on the substructure.\n\n\n\n\n\nWhen the TimeStructure is a TwoLevel, opscenarios returns a vector of StratOpScenarios.\n\n\n\n\n\nWhen the TimeStructure is a TwoLevel with RepresentativePeriods, opscenarios returns a vector of StratReprOpScenarios.\n\n\n\n\n\nWhen the TimeStructure is a StratNode, opscenarios returns the iterator StratNodeOpScens.\n\n\n\n\n\nWhen the TimeStructure is a StratNodeReprPeriod with a RepresentativePeriod, opscenarios returns the iterator StratNodeReprOpScens.\n\n\n\n\n\nWhen the TimeStructure is a StratNodeReprPeriod with a SingleReprPeriod, opscenarios returns the iterator StratNodeOpScens as the overall time structure does not include representative periods.\n\n\n\n\n\nWhen the TimeStructure is a StratNode with RepresentativePeriods, opscenarios returns an Array of all StratNodeReprOpScenarios.\n\n\n\n\n\nWhen the TimeStructure is a TwoLevelTree, opscenarios returns an Array of all StratNodeOpScenarios or StratNodeReprOpScenarios types, dependening on whether the TwoLevelTree includes RepresentativePeriods or not.\n\nThese are equivalent to a StratOpScenario and StratReprOpScenario of a TwoLevel time structure.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.strat_periods","page":"API reference","title":"TimeStruct.strat_periods","text":"strat_periods(ts::TimeStructure)\n\nThis function returns a type for iterating through the individual strategic periods of a TimeStructure. The type of the iterator is dependent on the type of the input TimeStructure. The elements returned of the iterator will be subtypes of AbstractStrategicPeriod.\n\nWhen the TimeStructure is a TimeStructure, strat_periods returns a SingleStrategicPeriodWrapper. This corresponds to the default behavior.\n\n\n\n\n\nWhen the TimeStructure is a TwoLevel, strat_periods returns the iterator StratPers.\n\nExample\n\nperiods = TwoLevel(5, SimpleTimes(10,1))\ntotal_dur = sum(duration_strat(sp) for sp in strategic_periods(periods))\n\n\n\n\n\nWhen the TimeStructure is a TwoLevelTree, strat_periods returns a StratTreeNodes type, which, through iteration, provides StratNode types.\n\nThese are equivalent to a StrategicPeriod of a TwoLevel time structure.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.strategic_periods","page":"API reference","title":"TimeStruct.strategic_periods","text":"strategic_periods(ts)\n\nConvenience constructor for strat_periods. Both names can be used interchangable.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.strategic_scenarios","page":"API reference","title":"TimeStruct.strategic_scenarios","text":"strategic_scenarios(ts::TwoLevelTree)\n\nThis function returns a type for iterating through the individual strategic scenarios of a TwoLevelTree. The type of the iterator is dependent on the type of the input TimeStructure.\n\nWhen the TimeStructure is a TimeStructure, strategic_scenarios returns a\n\n\n\n\n\nWhen the TimeStructure is a TwoLevelTree, strategic_scenarios returns the iterator StrategicScenarios.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.withprev","page":"API reference","title":"TimeStruct.withprev","text":"withprev(iter)\n\nIterator wrapper that yields (prev, t) where prev is the previous time period or nothing for the first time period.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.chunk","page":"API reference","title":"TimeStruct.chunk","text":"chunk(iter, n; cyclic = false)\n\nIterator wrapper that yields chunks where each chunk is an iterator over at most n consecutive time periods starting at each time period of the original iterator.\n\nIt is possible to get the n consecutive time periods in a cyclic fashion, by setting cyclic to true.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.chunk_duration","page":"API reference","title":"TimeStruct.chunk_duration","text":"chunk_duration(iter, dur)\n\nIterator wrapper that yields chunks based on duration where each chunk is an iterator over the following time periods until at least dur time is covered or the end is reached.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#api-prop_per","page":"API reference","title":"Properties of time periods","text":"","category":"section"},{"location":"reference/api/#TimeStruct.duration","page":"API reference","title":"TimeStruct.duration","text":"duration(t::TimePeriod)\n\nThe duration of a time period in number of operational time units.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.isfirst","page":"API reference","title":"TimeStruct.isfirst","text":"isfirst(t::TimePeriod)\n\nReturns true if the time period is the first in a sequence and has no previous time period\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.multiple","page":"API reference","title":"TimeStruct.multiple","text":"multiple(t::TimePeriod)\n\nReturns the number of times a time period should be counted for the whole time structure.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.multiple_strat","page":"API reference","title":"TimeStruct.multiple_strat","text":"multiple_strat(sp::AbstractStrategicPeriod, t)\n\nReturns the number of times a time period t should be accounted for when accumulating over one single unit of strategic time.\n\nExample\n\nperiods = TwoLevel(10, 1, SimpleTimes(24,1); op_per_strat = 8760)\nfor sp in strategic_periods(periods)\n    hours_per_year = sum(duration(t) * multiple_strat(sp, t) for t in sp)\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.probability","page":"API reference","title":"TimeStruct.probability","text":"probability(t::TimePeriod)\n\nReturns the probability associated with the time period.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#api-prof","page":"API reference","title":"Time profiles","text":"","category":"section"},{"location":"reference/api/#TimeStruct.FixedProfile","page":"API reference","title":"TimeStruct.FixedProfile","text":"FixedProfile(val)\n\nTime profile with a constant value for all time periods.\n\nExample\n\nprofile = FixedProfile(5)\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.OperationalProfile","page":"API reference","title":"TimeStruct.OperationalProfile","text":"OperationalProfile(vals::Vector{T}) where {T}\n\nTime profile with a value that varies with the operational time period. This profile cannot be accessed using AbstractOperationalScenario, AbstractRepresentativePeriod, or AbstractStrategicPeriod.\n\nIf too few values are provided, the last provided value will be repeated.\n\nExample\n\nprofile = OperationalProfile([1, 2, 3, 4, 5])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.RepresentativeProfile","page":"API reference","title":"TimeStruct.RepresentativeProfile","text":"RepresentativeProfile(vals::Vector{P}) where {T, P<:TimeProfile{T}}\nRepresentativeProfile(vals::Vector)\n\nTime profile with a separate time profile for each representative period. This profile cannot be accessed using AbstractStrategicPeriod.\n\nIf too few profiles are provided, the last given profile will be repeated.\n\nExample\n\n# Varying values in each representative period\nprofile = RepresentativeProfile([OperationalProfile([1, 2]), OperationalProfile([3, 4, 5])])\n # The same value in each representative period\nprofile = RepresentativeProfile([1, 2, 3, 4, 5])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.ScenarioProfile","page":"API reference","title":"TimeStruct.ScenarioProfile","text":"ScenarioProfile(vals::Vector{P}) where {T, P<:TimeProfile{T}}\nScenarioProfile(vals::Vector)\n\nTime profile with a separate time profile for each scenario. This profile cannot be accessed using AbstractRepresentativePeriod or AbstractStrategicPeriod.\n\nIf too few profiles are provided, the last given profile will be repeated.\n\nExample\n\n# Varying values in each operational scenario\nprofile = ScenarioProfile([OperationalProfile([1, 2]), OperationalProfile([3, 4, 5])])\n # The same value in each operational scenario\nprofile = ScenarioProfile([1, 2, 3, 4, 5])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.StrategicProfile","page":"API reference","title":"TimeStruct.StrategicProfile","text":"StrategicProfile(vals::Vector{P}) where {T, P<:TimeProfile{T}}\nStrategicProfile(vals::Vector)\n\nTime profile with a separate time profile for each strategic period.\n\nIf too few profiles are provided, the last given profile will be repeated.\n\nExample\n\n# Varying values in each strategic period\nprofile = StrategicProfile([OperationalProfile([1, 2]), OperationalProfile([3, 4, 5])])\n # The same value in each strategic period\nprofile = StrategicProfile([1, 2, 3, 4, 5])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.StrategicStochasticProfile","page":"API reference","title":"TimeStruct.StrategicStochasticProfile","text":"StrategicStochasticProfile(vals::Vector{<:Vector{P}}) where {T, P<:TimeProfile{T}}\nStrategicStochasticProfile(vals::Vector{<:Vector})\n\nTime profile with a separate time profile for each strategic node in a TwoLevelTree structure.\n\nIf too few profiles are provided, the last given profile will be repeated, both for strategic periods and branches within a strategic period.\n\nExample\n\n # The same value in each strategic period and branch\nprofile = StrategicStochasticProfile([[1], [21, 22]])\n# Varying values in each strategic period and branch\nprofile = StrategicStochasticProfile([\n    [OperationalProfile([11, 12])],\n    [OperationalProfile([21, 22]), OperationalProfile([31, 32])]\n])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#api-disc","page":"API reference","title":"Discounting","text":"","category":"section"},{"location":"reference/api/#TimeStruct.discount","page":"API reference","title":"TimeStruct.discount","text":"discount(t, time_struct, discount_rate; type, timeunit_to_year)\n\nCalculates the discount factor to be used for a time period t using a fixed 'discount_rate. There are two types of discounting available, either discounting to the start of the time period or calculating an approximate value for the average discount factor over the whole time period (type=\"avg\"`).\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.objective_weight","page":"API reference","title":"TimeStruct.objective_weight","text":"objective_weight(t, time_struct, discount_rate; type, timeunit_to_year)\n\nReturns an overall weight to be used for a time period t in the objective function considering both discounting, probability and possible multiplicity.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.Discounter","page":"API reference","title":"TimeStruct.Discounter","text":"Discounter(discount_rate, timeunit_to_year, ts)\n\nStructure to hold discount information to be used for a time structure.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#int-types","page":"Internal reference","title":"Internal types","text":"","category":"section"},{"location":"reference/internal/#int-types-super","page":"Internal reference","title":"Internal supertypes","text":"","category":"section"},{"location":"reference/internal/#TimeStruct.TimeStructurePeriod","page":"Internal reference","title":"TimeStruct.TimeStructurePeriod","text":"abstract type TimeStructurePeriod{T} <: TimeStructure{T}\n\nAbstract type representing different time structures that consists of one or more time periods. It is used for TimeStructures that can also act as index for periods, e.g., AbstractStrategicPeriod.\n\nThe type 'T' gives the data type used for the duration of the time periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.TimeStructInnerIter","page":"Internal reference","title":"TimeStruct.TimeStructInnerIter","text":"abstract type TimeStructInnerIter{T<:Duration}\n\nAbstract type representing different iterators for individual time structures. The difference to TimeStructure is that iterating through a TimeStructInnerIter will not provide a TimePeriod, but a TimeStructure.\n\nnote: Note\nTimeStructInnerIter and TimeStructOuterIter are comparable. The former is implemented for the inner level, that is if you want to use, e.g., opscenarios(OperationalScenarios()) while the latter is used for the outer level, e.g., opscenarios(StrategicPeriod()).\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.TimeStructOuterIter","page":"Internal reference","title":"TimeStruct.TimeStructOuterIter","text":"abstract type TimeStructOuterIter{T<:Duration}\n\nAbstract type representing different iterators for individual time structures. The difference to TimeStructure is that iterating through a TimeStructOuterIter will not provide a TimePeriod, but a TimeStructure.\n\nnote: Note\nTimeStructInnerIter and TimeStructOuterIter are comparable. The former is implemented for the inner level, that is if you want to use, e.g., opscenarios(OperationalScenarios()) while the latter is used for the outer level, e.g., opscenarios(StrategicPeriod()).\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#int-types-twoleveltree","page":"Internal reference","title":"Strategic period types (TwoLevelTree)","text":"","category":"section"},{"location":"reference/internal/#int-types-twoleveltree-single","page":"Internal reference","title":"Single types","text":"","category":"section"},{"location":"reference/internal/#TimeStruct.AbstractTreeNode","page":"Internal reference","title":"TimeStruct.AbstractTreeNode","text":"abstract type AbstractTreeNode{S,T} <: AbstractStrategicPeriod{S,T}\n\nAbstract base type for all tree nodes within a TwoLevelTree type.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNode","page":"Internal reference","title":"TimeStruct.StratNode","text":"struct StratNode{S, T, OP<:TimeStructure{T}} <: AbstractTreeNode{S,T}\n\nA structure representing a single strategic node of a TwoLevelTree. It is created through iterating through StratTreeNodes.\n\nIt is equivalent to a StrategicPeriod of a TwoLevel time structure when utilizing a TwoLevelTree.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StrategicScenario","page":"Internal reference","title":"TimeStruct.StrategicScenario","text":"struct StrategicScenario\n\nDesription of an individual strategic scenario. It includes all strategic nodes corresponding to a scenario, including the probability. It can be utilized within a decomposition algorithm.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#int-types-twoleveltree-iter","page":"Internal reference","title":"Iterator types","text":"","category":"section"},{"location":"reference/internal/#TimeStruct.AbstractTreeStructure","page":"Internal reference","title":"TimeStruct.AbstractTreeStructure","text":"abstract type AbstractTreeStructure{T} <: TimeStructOuterIter{T}\n\nAbstract base type for all tree timestructures within a TwoLevelTree type.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratTreeNodes","page":"Internal reference","title":"TimeStruct.StratTreeNodes","text":"struct StratTreeNodes{S,T,OP<:TimeStructure{T}} <: AbstractStratPers{T}\n\nType for iterating through the individual strategic nodes of a TwoLevelTree. It is automatically created through the function strat_periods, and hence, strategic_periods.\n\nIterating through StratTreeNodes using the WithPrev iterator changes the behaviour, although the meaning remains unchanged.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StrategicScenarios","page":"Internal reference","title":"TimeStruct.StrategicScenarios","text":"struct StrategicScenarios\n\nType for iteration through the individual strategic scenarios represented as StrategicScenario.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#int-types-strat_twolevel","page":"Internal reference","title":"Strategic period types (TwoLevel)","text":"","category":"section"},{"location":"reference/internal/#int-types-strat_twolevel-single","page":"Internal reference","title":"Single types","text":"","category":"section"},{"location":"reference/internal/#TimeStruct.AbstractStrategicPeriod","page":"Internal reference","title":"TimeStruct.AbstractStrategicPeriod","text":"abstract type AbstractStrategicPeriod{S,T} <: TimeStructurePeriod{T}\n\nAbstract type used for time structures that represent a strategic period. These periods are obtained when iterating through the strategic periods of a time structure declared by the function strat_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SingleStrategicPeriod","page":"Internal reference","title":"TimeStruct.SingleStrategicPeriod","text":"struct SingleStrategicPeriodWrapper{T,SP<:TimeStructure{T}} <: AbstractStrategicPeriod{T,T}\n\nA type representing a single strategic period supporting iteration over its time periods. It is created when iterating through SingleStrategicPeriodWrapper.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StrategicPeriod","page":"Internal reference","title":"TimeStruct.StrategicPeriod","text":"struct StrategicPeriod{S,T,OP<:TimeStructure{T}} <: AbstractStrategicPeriod{S,T}\n\nA type representing a single strategic period supporting iteration over its time periods. It is created when iterating through StratPers.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#int-types-strat_twolevel-iter","page":"Internal reference","title":"Iterator types","text":"","category":"section"},{"location":"reference/internal/#TimeStruct.AbstractStratPers","page":"Internal reference","title":"TimeStruct.AbstractStratPers","text":"abstract type AbstractStratPers{S,T} <: TimeStructInnerIter\n\nAbstract type used for time structures that represent a collection of strategic periods, obtained through calling the function strat_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SingleStrategicPeriodWrapper","page":"Internal reference","title":"TimeStruct.SingleStrategicPeriodWrapper","text":"struct SingleStrategicPeriodWrapper{T,SP<:TimeStructure{T}} <: AbstractStratPers{T}\n\nType for iterating through the individual strategic periods of a time structure without TwoLevel. It is automatically created through the function strat_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratPers","page":"Internal reference","title":"TimeStruct.StratPers","text":"struct StratPers{S,T,OP} <: AbstractStratPers{T}\n\nType for iterating through the individual strategic periods of a TwoLevel time structure. It is automatically created through the function strat_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#int-types-repr","page":"Internal reference","title":"Representative period types","text":"","category":"section"},{"location":"reference/internal/#int-types-repr-single","page":"Internal reference","title":"Single types","text":"","category":"section"},{"location":"reference/internal/#TimeStruct.AbstractRepresentativePeriod","page":"Internal reference","title":"TimeStruct.AbstractRepresentativePeriod","text":"abstract type AbstractRepresentativePeriod{T} <: TimeStructurePeriod{T}\n\nAbstract type used for time structures that represent a representative period. These periods are obtained when iterating through the representative periods of a time structure declared by the function repr_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SingleReprPeriod","page":"Internal reference","title":"TimeStruct.SingleReprPeriod","text":"struct SingleReprPeriod{T,OP<:TimeStructure{T}} <: AbstractRepresentativePeriod{T}\n\nA type representing a single representative period supporting iteration over its time periods. It is created when iterating through SingleReprPeriodWrapper.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.RepresentativePeriod","page":"Internal reference","title":"TimeStruct.RepresentativePeriod","text":"struct RepresentativePeriod{T,OP<:TimeStructure{T}} <: AbstractRepresentativePeriod{T}\n\nA type representing a single representative period supporting iteration over its time periods. It is created when iterating through ReprPers.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratReprPeriod","page":"Internal reference","title":"TimeStruct.StratReprPeriod","text":"struct StratReprPeriod{T,OP<:TimeStructure{T}} <: AbstractRepresentativePeriod{T}\n\nA type representing a single representative period supporting iteration over its time periods. It is created when iterating through StratReprPers.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNodeReprPeriod","page":"Internal reference","title":"TimeStruct.StratNodeReprPeriod","text":"struct StratNodeReprPeriod{T,OP<:TimeStructure{T}} <: AbstractRepresentativePeriod{T}\n\nA structure representing a single representative period of a StratNode of a TwoLevelTree. It is created through iterating through StratNodeReprPers.\n\nIt is equivalent to a StratReprPeriod of a TwoLevel time structure when utilizing a TwoLevelTree.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#int-types-repr-iter","page":"Internal reference","title":"Iterator types","text":"","category":"section"},{"location":"reference/internal/#TimeStruct.SingleReprPeriodWrapper","page":"Internal reference","title":"TimeStruct.SingleReprPeriodWrapper","text":"struct SingleReprPeriodWrapper{T,OP<:TimeStructure{T}} <: TimeStructInnerIter{T}\n\nType for iterating through the individual representative periods of a time structure without RepresentativePeriods. It is automatically created through the function repr_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.ReprPers","page":"Internal reference","title":"TimeStruct.ReprPers","text":"struct ReprPers{S,T,OP} <: TimeStructInnerIter{T}\n\nType for iterating through the individual representative periods of a RepresentativePeriods time structure. It is automatically created through the function repr_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratReprPers","page":"Internal reference","title":"TimeStruct.StratReprPers","text":"struct StratReprPers{T,OP<:TimeStructInnerIter{T}} <: TimeStructOuterIter{T}\n\nType for iterating through the individual representative periods of a StrategicPeriod time structure. It is automatically created through the function repr_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNodeReprPers","page":"Internal reference","title":"TimeStruct.StratNodeReprPers","text":"struct StratNodeReprPers{T,OP<:TimeStructInnerIter{T}} <: AbstractTreeStructure{T}\n\nType for iterating through the individual presentative periods of a StratNode. It is automatically created through the function repr_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#int-types-osc","page":"Internal reference","title":"Operational scenarios types","text":"","category":"section"},{"location":"reference/internal/#int-types-osc-single","page":"Internal reference","title":"Single types","text":"","category":"section"},{"location":"reference/internal/#TimeStruct.AbstractOperationalScenario","page":"Internal reference","title":"TimeStruct.AbstractOperationalScenario","text":"abstract type AbstractOperationalScenario{T} <: TimeStructurePeriod{T}\n\nAbstract type used for time structures that represent an operational scenario. These periods are obtained when iterating through the operational scenarios of a time structure declared by the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SingleScenario","page":"Internal reference","title":"TimeStruct.SingleScenario","text":"struct SingleScenario{T,SC<:TimeStructure{T}} <: AbstractRepresentativePeriod{T}\n\nA type representing a single operational scenario supporting iteration over its time periods. It is created when iterating through SingleScenarioWrapper.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.OperationalScenario","page":"Internal reference","title":"TimeStruct.OperationalScenario","text":"struct OperationalScenario{T,OP<:TimeStructure{T}} <: AbstractOperationalScenario{T}\n\nA type representing a single operational scenario supporting iteration over its time periods. It is created when iterating through OpScens.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.ReprOpScenario","page":"Internal reference","title":"TimeStruct.ReprOpScenario","text":"struct ReprOpScenario{T,OP<:TimeStructure{T}} <: AbstractOperationalScenario{T}\n\nA type representing a single operational scenarios supporting iteration over its time periods. It is created when iterating through RepOpScens.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratOpScenario","page":"Internal reference","title":"TimeStruct.StratOpScenario","text":"struct StratOpScenario{T,OP<:TimeStructure{T}} <: AbstractOperationalScenario{T}\n\nA type representing a single operational scenario supporting iteration over its time periods. It is created when iterating through StratOpScens.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratReprOpScenario","page":"Internal reference","title":"TimeStruct.StratReprOpScenario","text":"struct StratReprOpScenario{T, OP<:TimeStructure{T}} <: AbstractRepresentativePeriod{T}\n\nA type representing a single representative period supporting iteration over its time periods. It is created when iterating through StratReprPers.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNodeOpScenario","page":"Internal reference","title":"TimeStruct.StratNodeOpScenario","text":"struct StratNodeOpScenario{T,OP<:TimeStructure{T}}  <: AbstractOperationalScenario{T}\n\nA structure representing a single operational scenario for a strategic node supporting iteration over its time periods. It is created through iterating through StratNodeOpScens.\n\nIt is equivalent to a StratOpScenario of a TwoLevel time structure when utilizing a TwoLevelTree.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNodeReprOpScenario","page":"Internal reference","title":"TimeStruct.StratNodeReprOpScenario","text":"struct StratNodeReprOpScenario{T} <: AbstractOperationalScenario{T}\n\nA structure representing a single operational scenario for a representative period in A TwoLevelTree structure supporting iteration over its time periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#int-types-osc-iter","page":"Internal reference","title":"Iterator types","text":"","category":"section"},{"location":"reference/internal/#TimeStruct.SingleScenarioWrapper","page":"Internal reference","title":"TimeStruct.SingleScenarioWrapper","text":"struct SingleScenarioWrapper{T,OP<:TimeStructure{T}} <: TimeStructInnerIter{T}\n\nType for iterating through the individual operational scenarios of a time structure without OperationalScenarios. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.OpScens","page":"Internal reference","title":"TimeStruct.OpScens","text":"struct OpScens{T,OP} <: TimeStructInnerIter{T}\n\nType for iterating through the individual operational scenarios of a OperationalScenarios time structure. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.RepOpScens","page":"Internal reference","title":"TimeStruct.RepOpScens","text":"struct RepOpScens{T,OP<:TimeStructInnerIter{T}} <: TimeStructOuterIter{T}\n\nType for iterating through the individual operational scenarios of a RepresentativePeriod time structure. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratOpScens","page":"Internal reference","title":"TimeStruct.StratOpScens","text":"struct StratOpScens{T,OP<:TimeStructInnerIter{T}} <: TimeStructOuterIter{T}\n\nType for iterating through the individual operational scenarios of a StrategicPeriod time structure. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratReprOpScens","page":"Internal reference","title":"TimeStruct.StratReprOpScens","text":"struct StratReprOpScens{T,OP<:TimeStructInnerIter{T}} <: TimeStructOuterIter{T}\n\nType for iterating through the individual operational scenarios of a StrategicPeriod time structure with RepresentativePeriods. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNodeOpScens","page":"Internal reference","title":"TimeStruct.StratNodeOpScens","text":"struct StratNodeOpScens{T,OP<:TimeStructInnerIter{T}} <: AbstractTreeStructure{T}\n\nType for iterating through the individual operational scenarios of a StratNode. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNodeReprOpScens","page":"Internal reference","title":"TimeStruct.StratNodeReprOpScens","text":"struct StratNodeReprOpScens{T,OP<:TimeStructInnerIter{T}} <: AbstractTreeStructure{T}\n\nType for iterating through the individual operational scenarios of a StratNodeReprPeriod. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#int-types-periods","page":"Internal reference","title":"Operational period types","text":"","category":"section"},{"location":"reference/internal/#TimeStruct.TimePeriod","page":"Internal reference","title":"TimeStruct.TimePeriod","text":"abstract type TimePeriod\n\nAbstract type used for a uniform interface for iterating through time structures and indexing of time profiles.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SimplePeriod","page":"Internal reference","title":"TimeStruct.SimplePeriod","text":"struct SimplePeriod{T<:Number} <: TimePeriod\n\nTime period for a single operational period. It is created through iterating through a SimpleTimes time structure.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.CalendarPeriod","page":"Internal reference","title":"TimeStruct.CalendarPeriod","text":"struct CalendarPeriod{T} <: TimePeriod\n\nTime period for a single operational period. It is created through iterating through a CalendarTimes time structure with duration measured in hours (by default).\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.ScenarioPeriod","page":"Internal reference","title":"TimeStruct.ScenarioPeriod","text":"struct ScenarioPeriod{P} <: TimePeriod where {P<:TimePeriod}\n\nTime period for a single operational period. It is created through iterating through a OperationalScenarios time structure. It is as well created as period within OperationalPeriod when the time structure includes OperationalScenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.ReprPeriod","page":"Internal reference","title":"TimeStruct.ReprPeriod","text":"struct ReprPeriod{P} <: TimePeriod where {P<:TimePeriod}\n\nTime period for a single operational period. It is created through iterating through a RepresentativePeriods time structure. It is as well created as period within OperationalPeriod when the time structure includes RepresentativePeriods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.OperationalPeriod","page":"Internal reference","title":"TimeStruct.OperationalPeriod","text":"struct OperationalPeriod{P} <: TimePeriod where {P<:TimePeriod}\n\nTime period for a single operational period. It is created through iterating through a TwoLevel time structure.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.TreePeriod","page":"Internal reference","title":"TimeStruct.TreePeriod","text":"struct TreePeriod{P} <: TimePeriod where {P<:TimePeriod}\n\nTime period for iteration of a TwoLevelTree time structure. This period has in addition to an operational period also the two fields branch and prob_branch corresponding to the respective branch and probability of the branch\n\nwarn: Using OperationalScenarios\nThe probability will always only correspond to the branch probability, even when you utilize OperationalScenarios.  Using the function probability includes however the scenario probability.\n\n\n\n\n\n","category":"type"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation of the TimeStruct package!","category":"page"},{"location":"#What-is-TimeStruct?","page":"Introduction","title":"What is TimeStruct?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TimeStruct is a Julia package that supports the efficient development of optimization models with multi-horizon time modelling. The package is designed to be used in combination with the JuMP package for optimization modeling in Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The main concept is a TimeStructure which is an abstract type that enables iteration over a sequence of time periods. These time periods can serve as indices for optimization variables and can also facilitate the lookup of associated data values from time-varying profiles. By having a well-defined interface that is supported by all time structures, optimization models that are valid for arbitrary time structures can be written. The following example shows how a small optimization model can be set up in a function that accepts a general time structure and cost profile.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"    using JuMP, TimeStruct\n\n    function(periods::TimeStructure, cost::TimeProfile)\n        m = Model()\n        @variable(m, x[periods] >= 0)\n        @constraint(m, sum(x[t] for t in periods) >= 10)\n        @objective(m, Min, sum(cost[t] * x[t] for t in periods))\n    end","category":"page"},{"location":"#Why-use-TimeStruct?","page":"Introduction","title":"Why use TimeStruct?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"In complex optimization models, tracking relationships between time periods often requires substantial coding, especially with stochastic versions. Time constraints can introduce subtle bugs, particularly with linking constraints between periods or scenarios, like managing storage inventory or dispatch constraints. Extra indices for time and scenarios complicate the code, making it harder to read, maintain, and adapt.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"TimeStruct abstracts time structures, providing a common interface that simplifies the code and supports various time structures (operational, strategic/investment periods, and uncertainties). This abstraction allows modellers to focus on other model properties and facilitates running a single model for different time structures, and aids in the development of decomposition techniques.","category":"page"},{"location":"#How-to-get-started","page":"Introduction","title":"How to get started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package is registered in the general registry and can be installed in standard fashion","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add TimeStruct","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This documentation consists of a manual explaining concepts and giving examples as well as a complete API reference.","category":"page"},{"location":"#Cite","page":"Introduction","title":"Cite","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you find TimeStruct useful in your work, we kindly request that you cite the following:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"\n@misc{TimeStruct.jl,\n  author       = {Flatberg, Truls and Hellemo, Lars},\n  title        = {{TimeStruct.jl: Flexible time structures in optimization modelling}},\n  month        = Jan,\n  year         = 2024,\n  doi          = {10.5281/zenodo.10511399},\n  publisher    = {Zenodo},\n  url          = {https://zenodo.org/records/10511399}\n}","category":"page"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This material is based upon work supported by the Research Council of Norway through the projects ZeroKyst (328721), MaritimeNH3 (328679) and CleanExport (308811).","category":"page"}]
}
