var documenterSearchIndex = {"docs":
[{"location":"manual/profiles/#man-prof","page":"Time profiles","title":"Time profiles","text":"To provide data for different time structures, there is a flexible system of different time profiles that can be indexed by time periods.\n\nFixedProfile: Time profile with the same value for all time periods\nOperationalProfile: Time profile with values varying with operational time periods\nScenarioProfile: Holds a separate time profile for each operational scenario\nRepresentativeProfile: Holds a separate time profile for each representative period\nStrategicProfile: Holds a separate time profile for each strategic period\nStrategicStochasticProfile: Holds a separate time profile for each strategic node in a strategic tree\n\nThe following code example shows how these profile types can be combined in a flexible manner to produce different overall profiles.\n\nrep_periods = RepresentativePeriods(2, 365, [0.6, 0.4], [SimpleTimes(7,1), SimpleTimes(7,1)])\nperiods = TwoLevel(2, 365, rep_periods)\n\ncost = StrategicProfile(\n            [\n                RepresentativeProfile(\n                    [\n                        OperationalProfile([3, 3, 4, 3, 4, 6, 5]),\n                        FixedProfile(5)\n                    ]\n                ),\n                FixedProfile(7)\n            ]\n        )\n\nIllustration of profile values for the various time periods as defined in the profile example: (Image: Time profile values)","category":"section"},{"location":"showcases/emx/#show-emx","page":"EnergyModelsX","title":"EnergyModelsX","text":"EnergyModelsX (EMX) is a flexible multi-horizon energy system optimization framework using JuMP. It utilizes TimeStruct from the beginning and influenced some of the added features of TimeStruct. Its implementation is outlined in the following sections.","category":"section"},{"location":"showcases/emx/#show-emx-core","page":"EnergyModelsX","title":"Implementation of the core structures","text":"The core package EnergyModelsBase differentiates between variables indexed over strategic periods and variables indexed over operational periods, similar to the battery sizing example. As an example, consider the following two functions for variable declaration for a given ùíØ::TimeStructure:\n\nvariables_capacity(m, ùí©::Vector{<:Node}, ùí≥·µõ·µâ·∂ú, ùíØ, modeltype::EnergyModel) with, among others,\n@variable(m, cap_use[ùí©·∂ú·µÉ·µñ, ùíØ] >= 0)\n@variable(m, cap_inst[ùí©·∂ú·µÉ·µñ, ùíØ] >= 0)\nvariables_opex(m, ùí©::Vector{<:Node}, ùí≥·µõ·µâ·∂ú, ùíØ, modeltype::EnergyModel) with, among others,\nùíØ·¥µ‚Åø·µõ = strategic_periods(ùíØ)\n@variable(m, opex_var[ùí©·µí·µñ·µâÀ£, ùíØ·¥µ‚Åø·µõ])\n\nThese two functions highlight the simplicity of using TimeStruct, as the individual time structures allow for iterations within JuMP macros. In addition, it simplifies the index sets, as changing the number of intermediate time structures through incorporating, e.g., OperationalScenarios, does not require changes to the variable declarations. The change in the structure through the incorporation of the operational scenarios is instead available within the individual TimePeriod type.\n\nThe same is also true for constraint functions, as shown in constraints_capacity(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel):\n\n@constraint(m, [t ‚àà ùíØ], m[:cap_use][n, t] <= m[:cap_inst][n, t])\n\nVariables whose values are dependent on the previous operational period are only available for Storage nodes. Its implementation is rather complex, but it is entirely relying on the withprev functionality to decide whether it is the first operational period in a different TimeStructure as well as how it must behave in this situation.\n\nThe individual operational periods are linked in EnergyModelsBase through the internal function scale_op_sp for the multiplication\n\nduration(t) * multiple_strat(t_inv t) * probability(t)\n\nwhere t corresponds to an operational period and t_inv to a strategic period.","category":"section"},{"location":"showcases/emx/#show-emx-adv","page":"EnergyModelsX","title":"Advanced utilization","text":"","category":"section"},{"location":"showcases/emx/#show-emx-adv-withprev","page":"EnergyModelsX","title":"withprev and its application","text":"As outlined, neither OperationalScenarios nor RepresentativePeriods were available in the initial development of EMX. However, the adjustments toward including these were limited to constraints that require the previous periods, that is, constraints declared through the withprev functionality. All other constraints did not require any changes, as the respective TimePeriods included the required information.\n\nThe implementation of the Storage level balance provides an example of how TimeStruct can be used. It iterates through all potential subtypes of the given TimeStructure. Multiple dispatch is included to identify whether the TimeStructure includes OperationalScenarios or RepresentativePeriods. If this is the case, additional constraints can be incorporated. Due to the iteration (and storing) of all previous periods, it is possible to identify exactly what constraint should be utilized for the first operational period in a given TimeStructure.\n\ntip: Proposed workflow\nWhile it can be tempting to design models from the initial stage to include both operational scenarios and representative periods, it is beneficial to avoid including these. TimeStruct simplifies the introduction of either TimeStructure at a later stage. It is hence significantly easier to develop a model without considering complex time structures.If you do not have any constraints depending on the previous periods, you do not even have to make any changes to your model when including OperationalScenarios or RepresentativePeriods.","category":"section"},{"location":"showcases/emx/#show-emx-adv-chunk","page":"EnergyModelsX","title":"Chunks for unit commitment","text":"The functionality of TimeStruct for chunks based on the minimum required time is utilized in the unit commitment constraints of Reformer nodes in EnergyModelsHydrogen. In this context, we require a minimum time for starting the node, shutting the node down, and when the node is offline due to limitations in the dynamics of the chemical plant. The used approach is similar to the Storage level balance, utilizing the withprev functionality for the majority of the time structures. However, once at the lowest level, chunk_duration is used in addition to provide limits on changes between the different states. The eltypes of the iterator allow for further iterations to have access to the number of operational periods.","category":"section"},{"location":"showcases/emx/#show-emx-adv-strat","page":"EnergyModelsX","title":"Including strategic uncertainty","text":"EMX was not tested to also include strategic uncertainty as described in TwoLevelTree structure. The basic functionalities of EnergyModelsBase and the majority of the developed packages do, however, not have any problems with incorporating strategic uncertainty, as the strategic periods are not linked. In this case, the internal structure of TimeStruct allows the direct inclusion of strategic uncertainty without changes to the model. The exception is when using the withprev functionality on strategic periods, as is the case for the investments in EnergyModelsInvestments. However, it is expected that the inclusion does not require any changes directly to the code structure due to the function overload on the withprev functionality.","category":"section"},{"location":"tutorials/basic_usage/#Basic-Usage","page":"Basic usage","title":"Basic Usage","text":"This tutorial demonstrates the basic usage of generating flexible optimization models using the TimeStruct package in combination with JuMP.\n\nusing TimeStruct, JuMP","category":"section"},{"location":"tutorials/basic_usage/#Time-structures-and-time-profiles","page":"Basic usage","title":"Time structures and time profiles","text":"We start by defining a simple time structure with 4 periods of varying duration\n\nsimple = SimpleTimes(4, [1, 2, 3, 2])\n\nThe time structure can be iterated over to access the periods and the duration can be queried for each period.\n\nprint([duration(t) for t in simple])\n\nThe time periods can be used for lookups in time profiles of various types. For example, a fixed cost profile can be defined with a constant cost of 2.0 for all periods.\n\ncost_fixed = FixedProfile(2.0)\nprint([cost_fixed[t] for t in simple])\n\nA dynamic cost profile can be defined with varying costs for each period.\n\ncost_dynamic = OperationalProfile([1.0, 2.0, 3.0, 2.0])\nprint([cost_dynamic[t] for t in simple])\n\nOne of the main purposes of the TimeStruct package is to facilitate the modeling of optimization problems with multiple time horizons. For this, we define a two-level time structure with 2 strategic periods, each with the same operational time structure.\n\ntwo_level = TwoLevel(2, simple)\nnper = length(two_level)\n\nWe can also define a strategic cost profile with different cost profiles for each strategic period.\n\ncost_strategic = StrategicProfile([FixedProfile(2.0), FixedProfile(3.0)])\nprint([cost_strategic[t] for t in two_level])","category":"section"},{"location":"tutorials/basic_usage/#Optimization-modeling","page":"Basic usage","title":"Optimization modeling","text":"We are now ready to create a generic optimization model based on a given time structure and cost profile. This basic model illustrates the creation of optimization variables defined over the time structure, as well as constraints and an objective function based on the cost profile.\n\nfunction create_model_1(periods::TimeStructure, cost::TimeProfile)\n    m = Model()\n    @variable(m, x[periods])\n    @constraint(m, sum(x[t] for t in periods) <= 1)\n    @objective(m, Max, sum(cost[t] * x[t] for t in periods))\n    return m\nend\n\nUsing the simple time structure and fixed cost profile, we can create a first realization of the model.\n\nmodel = create_model_1(simple, cost_fixed)\nlatex_formulation(model)\n\nExchanging the fixed cost profile with the dynamic cost profile will change the model formulation to reflect the varying costs.\n\nmodel = create_model_1(simple, cost_dynamic)\nlatex_formulation(model)\n\nTime profiles are not connected to the time structure, so we can use the same cost profile for different time structures. This allows for a flexible modeling approach, e.g., during testing and model development.\n\nsimple_test = SimpleTimes([1])\nmodel = create_model_1(simple_test, cost_dynamic)\nlatex_formulation(model)","category":"section"},{"location":"tutorials/basic_usage/#Multiple-horizon-modeling","page":"Basic usage","title":"Multiple horizon modeling","text":"In a multi horizon optimization problem, there are typically constraints that are defined for each strategic period separately. To illustrate this, we create a model with a separate constraint for each strategic period using the strat_periods function to iterate over the strategic periods of the time structure.\n\nfunction create_model_2(periods::TimeStructure, cost::TimeProfile)\n    m = Model()\n    @variable(m, x[periods])\n    for sp in strat_periods(periods)\n        @constraint(m, sum(x[t] for t in sp) <= 1)\n    end\n    @objective(m, Max, sum(cost[t] * x[t] for t in periods))\n\n    return m\nend\n\nCreating a strategic model with a fixed cost profile, we see that we get a separate constraint for each of the two strategic periods.\n\nmodel = create_model_2(two_level, cost_fixed)\nlatex_formulation(model)\n\nUsing a strategic cost profile will differentiate the costs for each strategic period.\n\nmodel = create_model_2(two_level, cost_strategic)\nlatex_formulation(model)\n\nA general design principle of the TimeStruct package is to allow for simpler time structures, even in models that have separate modeling, e.g. for strategic periods. This is illustrated here by using the simple time structure in the strategic model. In this case, iterating over the strategic periods will result in a single strategic period that is equal to the original time structure.\n\nmodel = create_model_2(simple, cost_fixed)\nlatex_formulation(model)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"contribute/#con","page":"Contribute","title":"Contribute to TimeStruct","text":"Contributing to TimeStruct can be achieved in several different ways.","category":"section"},{"location":"contribute/#con-bug_rep","page":"Contribute","title":"File a bug report","text":"One approach to contributing to TimeStruct is by filing a bug report as an issue when unexpected behavior is occurring.\n\nWhen filing a bug report, please follow these guidelines:\n\nBe certain that the bug is a bug and originates in TimeStruct:\nIf the problem is within the results of your optimization problem, please be certain that your optimization model is correctly set up.\nIf the problem only appears for specific solvers, it is most likely not a bug in TimeStruct, but instead a problem with the solver wrapper for MathOptInterface. In this case, please contact the developers of the corresponding solver wrapper.\nLabel the issue as a bug, and\nProvide a minimum working example of a case in which the bug occurs. This minimum working example should not be based on a potential application of TimeStruct. Instead, it is important to focus purely on how TimeStruct behaves when the bug occurs.","category":"section"},{"location":"contribute/#con-feat_req","page":"Contribute","title":"Feature requests","text":"Although TimeStruct was designed with the aim of flexibility with respect to incorporating different time structures, it sometimes still requires additional features. Feature requests can be achieved through two approaches:\n\nCreate an issue describing the aim of the feature request, and\nIncorporate the feature request through a fork of the repository and open a pull request.","category":"section"},{"location":"contribute/#con-feat_req-issue","page":"Contribute","title":"Create an Issue","text":"Creating a new issue for a feature request is our standard approach for contributing to TimeStruct. Due to the modularity of TimeStruct's individual time structures, it is not necessarily straightforward to understand how to best incorporate required features into the framework without breaking existing time structures.\n\nWhen creating a new issue as a feature request, please follow these guidelines:\n\nReason for the feature: Please describe the reasoning for the feature request. What functionality do you require in TimeStruct?\nRequired outcome: What should be the outcome when including the feature and what should be the minimum requirements of the outcome?\nPotential solutions: Describe alternatives you consider. This step is not necessarily required, but can be helpful for identifying potential solutions.","category":"section"},{"location":"contribute/#con-feat_req-fork","page":"Contribute","title":"Incorporating the feature requests through a fork","text":"note: Note\nThe approach used for providing code is based on the excellent description from the JuMP package. We essentially follow the same approach with minor changes.\n\nIf you would like to work directly in TimeStruct, you can also incorporate your changes directly. In this case, it is beneficial to follow these outlined steps:","category":"section"},{"location":"contribute/#con-feat_req-fork-step_1","page":"Contribute","title":"Step 1: Create an issue","text":"Even if you plan to incorporate the code directly, we advise you to first follow the steps outlined in Create an Issue. This way, it is possible for us to comment on the solution approach(es) and assess potential problems with other time structures.\n\nBy creating an issue first, it is possible for us to comment directly on the proposed changes and assess whether we consider the proposed changes to follow the philosophy of the framework.","category":"section"},{"location":"contribute/#con-feat_req-fork-step_2","page":"Contribute","title":"Step 2: Create a fork of TimeStruct","text":"Contributing code to TimeStruct should follow the standard approach by creating a fork of the repository. All work on the code should occur within the fork.","category":"section"},{"location":"contribute/#con-feat_req-fork-step_3","page":"Contribute","title":"Step 3: Checkout a new branch in your local fork","text":"It is in general preferable to work on a separate branch when developing new components.","category":"section"},{"location":"contribute/#con-feat_req-fork-step_4","page":"Contribute","title":"Step 4: Make changes to the code base","text":"Incorporate your changes in your new branch. The changes should be commented to understand the thought process behind them. In addition, please provide new tests for the added functionality and be certain that the existing tests run. New tests should be based on a minimum working example in which the new concept is evaluated.\n\ntip: Tip\nIt is in our experience easiest to use the package TestEnv for testing the complete package.\n\nAside from the individual tests, it is required to use JuliaFormatter on the code.\n\nIt is not necessary to provide changes directly in the documentation. It can be easier to include these changes after the pull request is accepted in principle.","category":"section"},{"location":"contribute/#con-feat_req-fork-step_5","page":"Contribute","title":"Step 5: Create a pull request","text":"Once you are satisfied with your changes, create a pull request towards the main branch of the TimeStruct repository. We will internally assign the relevant person to the pull request.\n\nYou may receive quite a few comments with respect to the incorporation and how it may potentially affect other parts of the code. Please remain patient as it may take potentially some time before we can respond to the changes, although we try to answer as fast as possible.","category":"section"},{"location":"manual/discount/#man-disc","page":"Discounting","title":"Discounting","text":"For multi-year investment optimization models, it is common practice to use an objective that is discounted to get the net present value of the investment. Since investment decisions are usually made on a strategic level, discount factors are also calculated based on strategic periods.\n\nThe discount factor for a time period t is found by the discount function. There are two strategies for calculating the discount factor: either all discounting is calculated based on the start of the strategic period, or it is based on finding an approximation of the average value over the strategic period. The following example shows how these two types will differ for a planning period of 50 years, consisting of 5 periods of 10 years:\n\nusing TimeStruct\nts = TwoLevel(5, 10, SimpleTimes(1,1));\ndf_start = [discount(t, ts, 0.05; type = \"start\") for t in ts]\ndf_avg = [discount(t, ts, 0.05; type = \"avg\") for t in ts]\n\nWhile it is often normal to assume investments at the start of each strategic period, it can be more accurate to average the discount factor for operational costs that are accrued throughout the strategic period.\n\nWe also provide a method in which the average discount factor is calculated for the beginning of the years within a strategic period:\n\nusing TimeStruct\nts = TwoLevel(5, 10, SimpleTimes(5,1));\nsps = strategic_periods(ts)\ndf_start = [discount(sp, ts, 0.05; type = \"avg\") for sp in sps]\ndf_avg = [discount(sp, ts, 0.05; type = \"avg_year\") for sp in sps]\n\nThis approach results in a slightly higher discount factor.\n\nTo help set up the objective function in a typical optimization problem, there is a utility function objective_weight that returns the weight to give a time period in the objective, considering both discount factor, probability, and possible multiplicity.","category":"section"},{"location":"manual/iteration/#man-iter","page":"Iteration utilities","title":"Iteration utilities","text":"","category":"section"},{"location":"manual/iteration/#man-iter-basic","page":"Iteration utilities","title":"Basic iteration","text":"All time structures are iterable over their operational time periods:\n\nusing TimeStruct\n\nfunction iterate_ex(periods::TimeStructure)\n    for t in periods\n        println(t)\n    end\nend","category":"section"},{"location":"manual/iteration/#man-iter-prev","page":"Iteration utilities","title":"Iteration with previous","text":"In many settings, e.g., tracking of storage, it is convenient to have access to the previous time period. By using the custom iterator withprev, it is possible to return both the previous and current time period as a tuple when iterating:\n\nusing TimeStruct\nperiods = SimpleTimes(5, 1);\ncollect(withprev(periods))\n\nA variant of this is the withnext iterator that returns the current and next period (or nothing if none).","category":"section"},{"location":"manual/iteration/#man-iter-chunk","page":"Iteration utilities","title":"Iteration with chunks of time periods","text":"Sometimes it is convenient to iterate through the time periods as chunks of a fixed number of periods or minimum duration, e.g., in production planning with minimum production runs. To simplify this process, there are several iterator wrappers that allow this kind of iteration pattern.\n\nThe chunk function iterates through a time structure, returning subsequences of length at most n starting at each time period.\n\nperiods = SimpleTimes(5,1)\ncollect(collect(ts) for ts in chunk(periods, 3))\n\nThis wrapper can be used for, e.g., modeling of startup processes with a minimum uptime. The following example shows how this can be implemented as part of a JuMP model:\n\nusing JuMP, TimeStruct\n\nperiods = SimpleTimes(5,1)\n\nm = Model()\n@variable(m, startup[periods], Bin)\n@variable(m, shutdown[periods], Bin)\n\nfor ts in chunk(periods, 3)\n    @constraint(m, sum(shutdown[t] for t in ts) <= 3 * (1 - startup[first(ts)]))\nend\n\nfor cref in all_constraints(m, AffExpr, MOI.LessThan{Float64}) # hide\n    println(constraint_string(MIME(\"text/plain\"), cref; in_math_mode = true)) # hide\nend # hide\n\nSimilarly, if modeling startup decisions with a minimum downtime, it is possible to reverse the original time periods and then chunk:\n\nusing JuMP, TimeStruct # hide\nperiods = SimpleTimes(5,1) # hide\n\nm = Model() # hide\n@variable(m, startup[periods], Bin) # hide\n@variable(m, shutdown[periods], Bin) # hide\nfor ts in chunk(Iterators.reverse(periods), 3)\n    @constraint(m, sum(shutdown[t] for t in ts) <= 3 * (1 - startup[first(ts)]))\nend\n\nfor cref in all_constraints(m, AffExpr, MOI.LessThan{Float64}) # hide\n    println(constraint_string(MIME(\"text/plain\"), cref; in_math_mode = true)) # hide\nend # hide\n\nIt is also possible to get cyclic behavior by setting the cyclic argument to true. If reaching the end before the required number of time periods, the chunk will continue from the first time period.\n\nusing JuMP, TimeStruct # hide\nperiods = SimpleTimes(5,1) # hide\n\nm = Model() # hide\n@variable(m, startup[periods], Bin) # hide\n@variable(m, shutdown[periods], Bin) # hide\nfor ts in chunk(periods, 3; cyclic = true)\n    @constraint(m, sum(shutdown[t] for t in ts) <= 3 * (1 - startup[first(ts)]))\nend\nfor cref in all_constraints(m, AffExpr, MOI.LessThan{Float64}) # hide\n    println(constraint_string(MIME(\"text/plain\"), cref; in_math_mode = true)) # hide\nend # hide","category":"section"},{"location":"manual/iteration/#man-iter-chunk_dur","page":"Iteration utilities","title":"Chunks based on duration","text":"If working with a time structure that has varying duration for its time periods, it can be more convenient to use chunks based on their combined duration.\n\nThe chunk_duration function iterates through a time structure, returning subsequences with a duration of at least dur starting at each time period.\n\nperiods = SimpleTimes(5,[1, 2, 1, 1.5, 0.5, 2])\ncollect(collect(ts) for ts in chunk_duration(periods, 3))","category":"section"},{"location":"manual/iteration/#man-iter-index","page":"Iteration utilities","title":"Indexing of operational time structures","text":"It is possible to use indices for operational time structures, either directly using SimpleTimes or CalendarTimes, or by accessing an operational scenario.\n\nperiods = TwoLevel(3, 100, SimpleTimes(10,1));\n\nscenario = first(opscenarios(periods))\nscenario[3]","category":"section"},{"location":"manual/basic/#man-oper","page":"Operational time structures","title":"Operational time structures","text":"","category":"section"},{"location":"manual/basic/#man-oper-simple","page":"Operational time structures","title":"SimpleTimes","text":"The basic time structure is SimpleTimes which represents a continuous period of time divided into individual time periods of varying duration. The length of each time period is obtained by the duration(t) function.\n\nperiods = SimpleTimes(5, [1, 1, 1, 5, 5]);\ndurations = [duration(t) for t in periods]\n\n(Image: Illustration of SimpleTimes)","category":"section"},{"location":"manual/basic/#man-oper-calendar","page":"Operational time structures","title":"Calendar based","text":"For some applications, it is required to relate the time periods to actual calendar dates. This is supported by the time structure CalendarTimes that allows for creation and iteration of a calendar-based sequence of periods in combination with calendar arithmetic.\n\nThe following example shows the creation of a time structure with 12 months starting from January 1, 2024. The duration of each time period is given in hours by default, but it is possible to specify the time units to use by providing the period type:\n\nusing Dates\nyear = CalendarTimes(DateTime(2024, 1, 1), 12, Month(1));\nduration(first(year); dfunc = Dates.Day)\n\nYou can also make the time structure for a specific time zone, as shown in the following example with 3 days in late March with a transition to daylight saving time on the second day:\n\nusing TimeZones\nperiods = CalendarTimes(DateTime(2023, 3, 25), tz\"Europe/Berlin\", 3, Day(1));\nduration.(periods)","category":"section"},{"location":"manual/basic/#man-oper-osc","page":"Operational time structures","title":"Operational scenarios","text":"Operations often face uncertain operating conditions. In energy systems modeling, a typical example is the availability of wind and solar power. One method for accounting for this uncertainty is to have multiple operational scenarios that are used to evaluate the cost and feasibility of operations, where each scenario has a given probability of occurring.\n\nThe time structure OperationalScenarios represents an unordered collection of operational scenarios where each scenario has a separate time structure and an associated probability.\n\nusing TimeStruct, JuMP\nscenarios = OperationalScenarios(\n    3,\n    [SimpleTimes(5,1), SimpleTimes(7,2), SimpleTimes(10,1)],\n    [0.3, 0.2, 0.5]\n);\n\n(Image: Illustration of OperationalScenarios)\n\nSimilar to representative periods, each period has a multiple that is defined relative to the maximum duration for all scenarios. In addition, each time period has a probability equal to the probability of its scenario. Thus, we have that:\n\nsum(duration(t) * probability(t) * multiple(t) for t in scenarios)","category":"section"},{"location":"manual/basic/#man-oper-repr","page":"Operational time structures","title":"Representative periods","text":"In some cases, a fine-scale representation of the operations of the infrastructure for the whole time horizon is not feasible. A possible strategy is then to select one or more representative periods and use them to evaluate operational cost and feasibility. The time structure RepresentativePeriods consists of an ordered sequence of representative periods that represents a longer period of time. Each representative period covers a specified share of the whole time period.\n\nThe following example shows a year with daily resolution represented by two weeks with shares of 0.7 and 0.3, respectively.\n\nusing JuMP, TimeStruct\n\nperiods = RepresentativePeriods(\n    2,\n    365,\n    [0.7, 0.3],\n    [SimpleTimes(7,1), SimpleTimes(7,1)]\n);\n\nThe time periods can be iterated both for the whole time structure and individually by each representative period using the repr_periods function. This is illustrated here when setting up a JuMP model with a separate constraint for each representative period:\n\nm = Model();\n@variable(m, prod[periods] >= 0);\n\nfor rp in repr_periods(periods)\n    @constraint(m, sum(prod[t] for t in rp) <= 10)\nend\n\n@constraint(m, sum(prod[t] * multiple(t) for t in periods) <= 1);\n\nFor each time period, the multiple function returns how many times the given period should be counted when aggregating to the whole RepresentativePeriods structure. This will take into account both the duration and share of each representative period. Thus, we have that:\n\nsum(duration(t) * multiple(t) for t in periods)","category":"section"},{"location":"manual/multi/#man-multi","page":"Multi-horizon","title":"Multi-horizon time structures","text":"","category":"section"},{"location":"manual/multi/#man-multi-twolevel","page":"Multi-horizon","title":"TwoLevel structure","text":"The main motivation for the TimeStruct package is to support multi-horizon optimization models. The time structure TwoLevel allows for a two-level approach, combining an ordered sequence of strategic periods with given duration and an associated operational time structure.\n\nusing TimeStruct\nperiods = TwoLevel(\n    [SimpleTimes(5,1), SimpleTimes(5,1), SimpleTimes(5,1)],\n);\n\n(Image: Illustration of TwoLevel)\n\nThe following example shows a typical usage of a TwoLevel structure with investment decisions on a strategic level and operational decision variables. It is possible to iterate through each strategic period using the strat_periods function.\n\nusing JuMP\nm = Model();\n@variable(m, invest[strat_periods(periods)] >= 0);\n@variable(m, prod[periods] >= 0);\n\nfor sp in strat_periods(periods)\n    @constraint(m, sum(prod[t] for t in sp) <= invest[sp])\nend\n\nIt is also possible to combine a TwoLevel time structure with more complex operational structures like RepresentativePeriods and OperationalScenarios, alone or in combination, as shown in the following example and illustrated in the figure below.\n\noper = SimpleTimes(5,1);\nscen = OperationalScenarios([oper, oper, oper], [0.4, 0.5, 0.1]);\nrepr = RepresentativePeriods(2, 5, [0.5, 0.5], [oper, oper]);\nrepr_scen = RepresentativePeriods(2, 5, [0.5, 0.5], [scen, scen]);\n\nperiods = TwoLevel([scen, repr, repr_scen]);\n\n(Image: Complex TwoLevel)\n\nIn the above examples, the duration of the operational time structures has been equal to the duration of the strategic periods, but this is not required. If the duration of the operational time structure is shorter than the strategic period, this will be accounted for with the multiple function.\n\nIt is also sometimes convenient to use a different time unit for the strategic periods than the operational time periods. This is controlled by the op_per_strat field of the TwoLevel structure, which holds the number of operational periods per strategic period.\n\nA typical use case is an investment problem where one uses years to measure duration at the strategic level and hours/days on the operational level. Below is an example with 3 strategic periods of duration 5, 5, and 10 years, respectively, while the operational time structure is given by representative periods with duration in days. The op_per_strat is then set to 365.\n\nweek = SimpleTimes(7,1);\nrepr = RepresentativePeriods(2, 365, [0.6, 0.4], [week, week]);\nperiods = TwoLevel(3, [5, 5, 10], [repr, repr, repr], 365.0);","category":"section"},{"location":"manual/multi/#man-multi-twoleveltree","page":"Multi-horizon","title":"TwoLevelTree structure","text":"If there is uncertainty at a strategic level, this can be incorporated using the TwoLevelTree time structure. This structure is represented by a tree, with each node corresponding to a strategic period that contains an operational time structure. The operational time structure can be any combination of the described structures.\n\nThe following example demonstrates how to create a regular tree through a constructor (TwoLevelTree(duration::S, branching::Vector, ts::OP; op_per_strat::Float64 = 1.0) where {S,T,OP<:TimeStructure{T}}) where each strategic period spans 3 years and is represented by a week with daily resolution. The second argument of the constructor function specifies the number of branches at each stage of the tree, excluding the first stage.\n\nusing TimeStruct\nweek = SimpleTimes(7, 1);\ntwo_level_tree = TwoLevelTree(3, [3, 2], week; op_per_strat = 52.0);\n\n(Image: Illustration of TwoLevelTree)\n\nThe branching probabilities are equal for all branches, as indicated in green in the figure.\n\nWe also provide the possibility of having differing tree structures through the application of the TreeNode type. A TreeNode approach for the above time structure would be given by:\n\nusing TimeStruct\nweek = SimpleTimes(7, 1);\ntwo_level_tree = TwoLevelTree(\n    TreeNode(3, week, [\n        TreeNode(3, week, 2,\n            TreeNode(3, week)\n        )\n        TreeNode(3, week, [0.5, 0.5],\n            TreeNode(3, week)\n        )\n        TreeNode(3, week, [\n            TreeNode(3, week),\n            TreeNode(3, week),\n        ])\n    ]);\n    op_per_strat = 52.0\n)\n\nSimilar to TwoLevel, the strategic nodes can be iterated using strat_periods. It is possible to connect the nodes to their predecessor by iterating using the withprev iterator, which returns a tuple with the parent (or nothing if no parent) together with the node itself. This provides the flexibility to track decisions in the tree, as shown by the following example that allows investment into new capacity in each strategic node while tracking the accumulated capacity.\n\nusing JuMP\n\nm = Model();\nstrat_pers = strat_periods(two_level_tree);\n@variable(m, invest[strat_pers], Bin);\n@variable(m, cap[strat_pers] >= 0);\nfor (prev, sp) in withprev(strat_pers)\n    if !isnothing(prev)\n        @constraint(m, cap[sp] == cap[prev] + 10 * invest[prev])\n    end\nend\n\nTo ensure consistency across the tree, it is possible to iterate through all strategic scenarios in the tree using strategic_scenarios. Here, each scenario is a path from the root node to one of the leaves of the tree. In the example above, if we only allow one investment in the planning period, this can be added by restricting the number of investments in each scenario:\n\nfor sc in strategic_scenarios(two_level_tree)\n    @constraint(m, sum(invest[sp] for sp in strat_periods(sc)) <= 1)\nend","category":"section"},{"location":"tutorials/battery_sizing/#Battery-sizing","page":"Battery sizing","title":"Battery sizing","text":"This tutorial demonstrates how to formulate a battery sizing problem using the TimeStruct package in combination with JuMP. We start by defining the operational model of the battery, which includes the constraints and the objective function. Then, we extend the model to include the strategic decisions of the battery sizing.\n\nFor this tutorial, we use the HiGHS solver for optimization:\n\nusing TimeStruct\nusing JuMP\nusing HiGHS\n\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false)","category":"section"},{"location":"tutorials/battery_sizing/#Operational-model","page":"Battery sizing","title":"Operational model","text":"We start by defining the operational model of the battery. The battery has a fixed capacity and can charge and discharge energy to cover a given demand profile. Additionally, the demand can be covered by purchasing energy from the spot market with a given price profile.\n\nfunction create_operational(\n    periods::TimeStructure,\n    capacity,\n    demand::TimeProfile,\n    price::TimeProfile,\n)\n    model = Model()\n\n    @variable(model, soc[periods] >= 0)         # State of charge of the battery\n    @variable(model, charge[periods] >= 0)      # Energy charged to the battery\n    @variable(model, discharge[periods] >= 0)   # Energy discharged from the battery\n    @variable(model, spot[periods] >= 0)        # Energy purchased from the spot market\n\n    for (prev, t) in withprev(periods)\n        @constraint(model, soc[t] <= capacity)\n        soc_prev = isnothing(prev) ? soc[last(periods)] : soc[prev]\n        @constraint(model, soc[t] == soc_prev + charge[t] - discharge[t])\n        @constraint(model, spot[t] + discharge[t] - charge[t] == demand[t])\n    end\n\n    @objective(model, Min, sum(multiple(t) * price[t] * spot[t] for t in periods))\n    return model\nend\n\nNote the use of the special iterator  withprev to iterate over the periods with the previous period, returning nothing for the first period. In this example we have opted to use a cyclic constraint for the state of charge, i.e. the state of charge of the last period is used as the initial state of charge for the first period.\n\nTo test the model, we create a simple example with 24 hourly periods, a capacity of 20, a fixed demand of 5.0, and a time dependent price profile that varies sinusoidally over a day.\n\nperiods = SimpleTimes(24, 1)\ncapacity = 20\ndemand = FixedProfile(5.0)\nprice = OperationalProfile([1 + 0.3 * sin(i) for (i, t) in enumerate(periods)])\n\nmodel = create_operational(periods, capacity, demand, price)\nset_optimizer(model, optimizer)\noptimize!(model)\nprintln(\"Objective value: \", objective_value(model))","category":"section"},{"location":"tutorials/battery_sizing/#Strategic-model","page":"Battery sizing","title":"Strategic model","text":"We now extend the operational model to include the strategic decisions of the battery sizing. For simplicity, we assume that the battery capacity can be chosen independently for each stragic period, e.g., by renting a battery of a given capacity for each strategic period.\n\nTo simplify the process of defining the strategic model, we define helper functions to create the operational variables, constraints, and objective function.\n\nfunction create_operational_variables(model, periods)\n    @variable(model, soc[periods] >= 0)\n    @variable(model, charge[periods] >= 0)\n    @variable(model, discharge[periods] >= 0)\n    @variable(model, spot[periods] >= 0)\nend\n\nfunction create_operational_constraints(model, periods, capacity, demand)\n    soc, charge, discharge = model[:soc], model[:charge], model[:discharge]\n    spot = model[:spot]\n    for (prev, t) in withprev(periods)\n        @constraint(model, soc[t] <= capacity)\n        soc_prev = isnothing(prev) ? soc[last(periods)] : soc[prev]\n        @constraint(model, soc[t] == soc_prev + charge[t] - discharge[t])\n        @constraint(model, spot[t] + discharge[t] - charge[t] == demand[t])\n    end\nend\n\nfunction create_operational_objective(model, periods, price)\n    spot = model[:spot]\n    el_cost = sum(multiple(t) * probability(t) * price[t] * spot[t] for t in periods)\n    return el_cost\nend\n\nNote the use of the multiple function to include the multiplier of each operational period for time structures where the operational periods do not cover the complete strategic periods and probability for periods that have an associated probability when using operational scenarios.\n\nWe can now define the strategic model by creating a battery sizing decision for each strategic period. To obtain the strategic periods, we use the strat_periods iterator.\n\nfunction create_strategic_model(\n    periods::TimeStructure,\n    price::TimeProfile,\n    demand::TimeProfile,\n    capex,\n)\n    model = Model()\n    @variable(model, cap[strat_periods(periods)] >= 0)\n\n    create_operational_variables(model, periods)\n    for sp in strat_periods(periods)\n        create_operational_constraints(model, sp, cap[sp], demand)\n    end\n    op_cost = create_operational_objective(model, periods, price)\n    investment_cost = sum(cap[sp] * capex[sp] for sp in strat_periods(periods))\n    @objective(model, Min, investment_cost + op_cost)\n    return model\nend\n\nNote that each strategic period can be iterated as a separate time structure and be used to define the operational constraints.\n\nTo test the model, we create a simple example with 7 strategic periods of 24 hourly periods each\n\nperiods = TwoLevel(7, SimpleTimes(24, 1))\ndemand = StrategicProfile([5.0 + 0.5 * i for i in 1:7])\nprice = OperationalProfile([1 + 0.3 * sin(i) for i in 1:24])\ncapex = StrategicProfile([2 - 0.1 * i for i in 1:7])\n\nmodel = create_strategic_model(periods, price, demand, capex)\n\nset_optimizer(model, optimizer)\noptimize!(model)\nprintln(\"Objective value: \", objective_value(model))\nprintln(\"Battery sizing: \", [value(model[:cap][sp]) for sp in strat_periods(periods)])","category":"section"},{"location":"tutorials/battery_sizing/#Representative-periods","page":"Battery sizing","title":"Representative periods","text":"In large scale models, it is common to use representative periods to reduce the computational burden by aggregating the time series involved and use these to represent a larger share of the planning period. With TimeStruct, we can create constraints separately for each representative period by using the repr_periods iterator.\n\nfunction create_strat_repr_model(periods, price, demand, capex)\n    model = Model()\n    @variable(model, cap[strat_periods(periods)] >= 0)\n\n    create_operational_variables(model, periods)\n    for sp in strat_periods(periods)\n        for rp in repr_periods(sp)\n            create_operational_constraints(model, rp, cap[sp], demand)\n        end\n    end\n\n    op_cost = create_operational_objective(model, periods, price)\n    investment_cost = sum(cap[sp] * capex[sp] for sp in strat_periods(periods))\n    @objective(model, Min, investment_cost + op_cost)\n    return model\nend\n\nSetting up the model with representative periods requires defining the representative periods and the representative price profile.\n\nperiods = TwoLevel(\n    5,\n    1,\n    RepresentativePeriods(8760, [0.3, 0.2, 0.4, 0.1], SimpleTimes(24, 1));\n    op_per_strat = 8760,\n)\nrepr_price = RepresentativeProfile([0.9 * price, 1.1 * price, 0.8 * price, 1.2 * price])\n\nIn this example, we use 5 strategic periods of length 1 year each. Each strategic period is represented by 4 representative periods of 24 hours each. Note the use of the parameter op_per_strat to define the number of operational periods per strategic period.\n\nmodel = create_strat_repr_model(periods, repr_price, demand, capex)\nset_optimizer(model, optimizer)\noptimize!(model)\nprintln(\"Objective value: \", objective_value(model))\nprintln(\"Battery sizing: \", [value(model[:cap][sp]) for sp in strat_periods(periods)])","category":"section"},{"location":"tutorials/battery_sizing/#Operational-scenarios","page":"Battery sizing","title":"Operational scenarios","text":"Finally, we can extend the model to include operational scenarios to account for operational uncertainty in the battery sizing problem. Typically, the spot prices are uncertain and can be modeled as a set of scenarios with a specified probability for each scenario.\n\nfunction create_strat_repr_scen_model(periods, price, demand, capex)\n    model = Model()\n    @variable(model, cap[strat_periods(periods)] >= 0)\n\n    create_operational_variables(model, periods)\n    for sp in strat_periods(periods)\n        for rp in repr_periods(sp)\n            for sc in opscenarios(rp)\n                create_operational_constraints(model, sc, cap[sp], demand)\n            end\n        end\n    end\n    op_cost = create_operational_objective(model, periods, price)\n    investment_cost = sum(cap[sp] * capex[sp] for sp in strat_periods(periods))\n    @objective(model, Min, investment_cost + op_cost)\n    return model\nend\n\nThe only difference in the model is the use of the opscenarios iterator to iterate over the operational scenarios.\n\nThe time structure is similar to the previous example, but we now include 10 operational scenarios for each representative period.\n\nperiods = TwoLevel(\n    5,\n    1,\n    RepresentativePeriods(\n        8760,\n        [0.3, 0.2, 0.4, 0.1],\n        OperationalScenarios(10, SimpleTimes(24, 1)),\n    );\n    op_per_strat = 8760,\n)\n\nprice = RepresentativeProfile([\n    0.9 * ScenarioProfile([price + 0.1 * rand() for sc in 1:10]),\n    1.1 * ScenarioProfile([price + 0.2 * rand() for sc in 1:10]),\n    0.8 * ScenarioProfile([price + 0.05 * rand() for sc in 1:10]),\n    1.2 * ScenarioProfile([price + 0.08 * rand() for sc in 1:10]),\n])\n\nmodel = create_strat_repr_scen_model(periods, price, demand, capex)\nset_optimizer(model, optimizer)\noptimize!(model)\nprintln(\"Objective value: \", objective_value(model))\nprintln(\"Battery sizing: \", [value(model[:cap][sp]) for sp in strat_periods(periods)])\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"reference/api/#api","page":"API reference","title":"Interface for using TimeStruct","text":"","category":"section"},{"location":"reference/api/#api-ts","page":"API reference","title":"Available time structures","text":"","category":"section"},{"location":"reference/api/#api-ts-abstract","page":"API reference","title":"Abstract supertypes","text":"","category":"section"},{"location":"reference/api/#api-ts-con","page":"API reference","title":"Concrete types","text":"","category":"section"},{"location":"reference/api/#api-prop_ts","page":"API reference","title":"Properties of time structures","text":"The following properties are included for a TwoLevelTree time structure:","category":"section"},{"location":"reference/api/#api-iter","page":"API reference","title":"Iterating time structures","text":"","category":"section"},{"location":"reference/api/#api-iter-ts","page":"API reference","title":"For individual time structures","text":"","category":"section"},{"location":"reference/api/#api-iter-spec","page":"API reference","title":"Specialized iterators","text":"","category":"section"},{"location":"reference/api/#api-prop_per","page":"API reference","title":"Properties of time periods","text":"","category":"section"},{"location":"reference/api/#api-prof","page":"API reference","title":"Time profiles","text":"","category":"section"},{"location":"reference/api/#api-disc","page":"API reference","title":"Discounting","text":"","category":"section"},{"location":"reference/api/#api-disc-type","page":"API reference","title":"Type","text":"","category":"section"},{"location":"reference/api/#api-disc-func","page":"API reference","title":"Functions","text":"","category":"section"},{"location":"reference/api/#TimeStruct.TimeStructure","page":"API reference","title":"TimeStruct.TimeStructure","text":"abstract type TimeStructure{T<:Duration}\n\nAbstract type representing different time structures that consists of one or more time periods.\n\nThe type 'T' gives the data type used for the duration of the time periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.SimpleTimes","page":"API reference","title":"TimeStruct.SimpleTimes","text":"struct SimpleTimes{T} <: TimeStructure{T}\n\nSimpleTimes(len::Integer, duration::Vector{T}) where {T<:Duration}\nSimpleTimes(len::Integer, duration::Duration)\nSimpleTimes(dur::Vector{T}) where {T<:Duration}\n\nA simple time structure consisting of consecutive time periods of varying duration. SimpleTimes is always the lowest level in a TimeStruct time structure, if used.\n\nAn alternative to SimpleTimes is CalendarTimes\n\nExample\n\nuniform = SimpleTimes(5, 1.0) # 5 periods of equal length\nvarying = SimpleTimes([2, 2, 2, 4, 10]) # 5 periods of varying length\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.CalendarTimes","page":"API reference","title":"TimeStruct.CalendarTimes","text":"struct CalendarTimes{T} <: TimeStructure{T}\n\nCalendarTimes(start_date, length, period)\nCalendarTimes(start_date, end_date, period)\nCalendarTimes(start_date, timezone, length, period)\nCalendarTimes(start_date, end_date, timezone, period)\n\nA time structure that iterates flexible calendar periods using calendar arithmetic. This time structure can be used at the lowest level of time structures similar to SimpleTimes.\n\nExample\n\nts = CalendarTimes(Dates.DateTime(2023, 1, 1), 12, Dates.Month(1))\nts_zoned = CalendarTimes(Dates.DateTime(2023, 1, 1), tz\"Europe/Berlin\", 52, Dates.Week(1))\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.OperationalScenarios","page":"API reference","title":"TimeStruct.OperationalScenarios","text":"struct OperationalScenarios{T,OP<:TimeStructure{T}} <: TimeStructure{T}\n\nOperationalScenarios(len::Integer, scenarios::Vector{OP}, probability::Vector{<:Real}) where {T, OP<:TimeStructure{T}\nOperationalScenarios(len::Integer, oper::TimeStructure{T})\n\nOperationalScenarios(oper::Vector{<:TimeStructure{T}}, prob::Vector)\nOperationalScenarios(oper::Vector{<:TimeStructure{T}})\n\nTime structure that have multiple scenarios where each scenario has its own time structure and an associated probability. These scenarios are in general represented as SimpleTimes.\n\nnote: Note\nThe TimeStructures of all operational scenarios must use the same type for the duration, i.e., either Integer or Float.\nIf the probability is not specified, it assigns the same probability to each scenario.\nIt is possible that sum(probability) is larger or smaller than 1. This can lead to problems in your application. Hence, it is advised to scale it. Currently, a warning will be given if the period shares do not sum to one, as an automatic scaling will correspond to a breaking change.\n\nExample\n\nThe following examples create a time structure with 2 operational scenarios corresponding to a single day with equal probability.\n\nday = SimpleTimes(24, 1)\nOperationalScenarios(2, day)\nOperationalScenarios([day, day], [0.5, 0.5])\nOperationalScenarios([day, day])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.RepresentativePeriods","page":"API reference","title":"TimeStruct.RepresentativePeriods","text":"struct RepresentativePeriods{S<:Duration,T,OP<:TimeStructure{T}} <: TimeStructure{T}\n\nRepresentativePeriods(len::Integer, duration::S, period_share::Vector{<:Real}, rep_periods::Vector{OP}) where {S<:Duration, T, OP<:TimeStructure{T}}\nRepresentativePeriods(len::Integer, duration::S, rep_periods::TimeStructure{T}) where {S<:Duration, T}\n\nRepresentativePeriods(duration::S, period_share::Vector{<:Real}, rep_periods::Vector{<:TimeStructure{T}}) where {S<:Duration, T}\nRepresentativePeriods(duration::S, period_share::Vector{<:Real}, rep_periods::TimeStructure{T}) where {S<:Duration, T}\n\nRepresentativePeriods(duration::S, rep_periods::Vector{<:TimeStructure{T}}) where {S<:Duration, T}\n\nTime structure that allows a time period to be represented by one or more shorter representative time periods.\n\nThe representative periods are an ordered sequence of TimeStructures that are used for each representative period. In addition, each representative period has an associated share that specifies how much of the total duration that is attributed to it.\n\nnote: Note\nThe TimeStructures of all representative periods must use the same type for the duration, i.e., either Integer or Float.\nIf the field period_share is not specified, it assigns the same probability to each representative period.\nIt is possible that sum(period_share) is larger or smaller than 1. This can lead to problems in your application. Hence, it is advised to scale it. Currently, a warning will be given if the period shares do not sum to one, as an automatic scaling will correspond to a breaking change.\nIf you include OperationalScenarios in your time structure, it is important that the scenarios are within the representative periods, and not the other way.\n\nExample\n\n# A year represented by two days with hourly resolution and relative shares of 0.7 and 0.3\nRepresentativePeriods(8760, [0.7, 0.3], [SimpleTimes(24, 1), SimpleTimes(24,1)])\nRepresentativePeriods(8760, [0.7, 0.3], SimpleTimes(24, 1))\n\n# A year represented by two days with hourly resolution and relative shares of 0.5\nRepresentativePeriods(2, 8760, SimpleTimes(24, 1))\nRepresentativePeriods(8760, [SimpleTimes(24, 1), SimpleTimes(24,1)])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.TwoLevel","page":"API reference","title":"TimeStruct.TwoLevel","text":"struct TwoLevel{S<:Duration,T,OP<:TimeStructure{T}} <: TimeStructure{T}\n\nTwoLevel(len::Integer, duration::Vector{S}, operational::Vector{OP}, op_per_strat::Float64) where {S<:Duration, T, OP<:TimeStructure{T}}\nTwoLevel(len::Integer, duration::S, oper::TimeStructure{T}; op_per_strat) where {S, T}\nTwoLevel(len::Integer, oper::TimeStructure{T}; op_per_strat) where {T}\n\nTwoLevel(duration::S, oper::Vector{OP}; op_per_strat) where {S, T, OP<:TimeStructure{T}}\nTwoLevel(duration::Vector{S}, oper::TimeStructure{T}; op_per_strat) where {S, T}\n\nTwoLevel(oper::Vector{<:TimeStructure{T}}; op_per_strat) where [T]\n\nA time structure with two levels of time periods.\n\nOn the top level it has a sequence of strategic periods of varying duration. For each strategic period, a separate time structure is used for operational decisions. Iterating the structure will go through all operational periods. It is possible to use different time units for the two levels by providing the number of operational time units per strategic time unit through the keyword argument op_per_strat.\n\nPotential time structures are SimpleTimes, CalendarTimes, OperationalScenarios, or RepresentativePeriods, as well as combinations of these.\n\nnote: Note\nThe TimeStructures of all strategic periods must use the same type for the duration, i.e., either Integer or Float.\n\ndanger: Usage of op_per_strat\nThe optional keyword op_per_strat is important for the overall calculations. If you use an hourly resolution for your operational period and yearly for investment periods, then you have to specify it as op_per_strat = 8760.0. Not specifying it would imply that you use the same unit for strategic and operational periods.\n\nnote: Not specifying the duration\nIf you do not specify the field duration, then it is calculated given the function_total_duration(op) / op_per_strat for op in operin which oper::Vector{<:TimeStructure{T}. The internal function _total_duration corresponds in this case to the sum of the duration of all operational periods divided by the value of the field op_per_strat.\n\nExample\n\n# 5 years with 24 hours of operations for each year. Note that in this case we use as unit\n# `hour` for both the duration of strategic periods and operational periods\nTwoLevel(5, 8760, SimpleTimes(24, 1))\n\n# The same time structure with the unit `year` for strategic periods and unit `hour` for\n# operational periods\nTwoLevel(5, 1, SimpleTimes(24, 1); op_per_strat=8760.0)\n\n# All individual constructors\nTwoLevel(2, ones(2), [SimpleTimes(24, 1), SimpleTimes(24, 1)], 8760.0)\nTwoLevel(2, 1, SimpleTimes(24, 1); op_per_strat=8760.0)\nTwoLevel(1, [SimpleTimes(24, 1), SimpleTimes(24, 1)]; op_per_strat=8760.0)\nTwoLevel(ones(2), SimpleTimes(24, 1); op_per_strat=8760.0)\n\n# Constructors without duration\nTwoLevel([SimpleTimes(24, 1), SimpleTimes(24, 1)]; op_per_strat=8760.0)\nTwoLevel(2, SimpleTimes(24, 1); op_per_strat=8760.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.TwoLevelTree","page":"API reference","title":"TimeStruct.TwoLevelTree","text":"mutable struct TwoLevelTree{S,T,OP<:AbstractTreeNode{S,T}} <: TimeStructure{T}\n\nTwoLevelTree(node::TreeNode; op_per_strat=8760.0)\nTwoLevelTree(duration::S, branching::Vector, ts::OP; op_per_strat::Float64 = 1.0) where {S,T,OP<:TimeStructure{T}}\n\nTime structure allowing for a tree structure for the strategic level. For each strategic node in the tree, a separate time structure is used for operational decisions. Iterating the structure will go through all operational periods.\n\nThe default approach for creating a TwoLevelTree is by providing the root TreeNode with all its children nodes. In the case of a regular structure, that is, all children nodes have the same duration, time structure ts, probability, and children itself, you can use a simplified constructor with the branching vector. The vector branching specifies the number of branchings at each stage of the tree, excluding the first stage. The branches at each stage will all have equal probability, duration, and time structure.\n\nwarning: Additional iterators\nTwoLevelTree utilizes a separate withprev method which is equivalent to the existing method for the other time structures. withnext, chunk, and chunk_duration are not implemented and will result in an error when used.\n\nExample\n\n# Declare the individual time structure\nday = SimpleTimes(24, 1)\n\n# Regular tree with 4 strategic periods of duration 5, 3 branches for the second strategic\n# period, and 6 branches in the third and fourth strategic periods\nregtree_1 = TwoLevelTree(5, [3, 2, 1], day)\n\n# Equivalent structure using `TreeNode` and the different constructors\nregtree_2 = TwoLevelTree(\n    TreeNode(5, day, [\n        TreeNode(5, day, 2,\n            TreeNode(5, day, TreeNode(5, day))\n        )\n        TreeNode(5, day, [0.5, 0.5],\n            TreeNode(5, day, TreeNode(5, day))\n        )\n        TreeNode(5, day, [\n            TreeNode(5, day, TreeNode(5, day)),\n            TreeNode(5, day, TreeNode(5, day)),\n        ])\n    ])\n)\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.TreeNode","page":"API reference","title":"TimeStruct.TreeNode","text":"struct TreeNode{S,T,OP<:TimeStructure{T},COP<:Union{Nothing, TimeStructure{T}}}\n\nTreeNode(duration::Number, ts::TimeStructure)\nTreeNode(duration::Number, ts::TimeStructure, child::TreeNode)\nTreeNode(duration::Number, ts::TimeStructure, len::Int64, children::TreeNode)\nTreeNode(duration::Number, ts::TimeStructure, children::Vector{<:TreeNode})\nTreeNode(duration::Number, ts::TimeStructure, probability::Vector{<:Float64}, sub_tn::TreeNode)\n\nA subtype introduced for creating all potential structures of a TwoLevelTree.\n\nA TreeNode is similar to a StratNode but does not require the calculation of all required parameters by the user. The parameters are automatically calculated when creating a TwoLevelTree for a given TreeNode.\n\nThe TreeNode has a given duration which is similar to the duration of a TwoLevel time structure and a single TimeStructure ts.\n\nnote: Note\nThe TimeStructure of the TreeNode and all children must use the same type for the duration, .i.e., either Integer or Float.\n\nConstructors\n\nThe following constructors are included for the type:\n\nTreeNode(duration::Number, ts::TimeStructure): the last TreeNode within a branch, i.e., the leaf of the branch. It does not posess a child.\nTreeNode(duration::Number, ts::TimeStructure, child::TreeNode): a TreeNode with only a single child. i.e., a linear continuation.\nTreeNode(duration::Number, ts::TimeStructure, len::Int64, children::TreeNode): a TreeNode with len children, each with the same structure and probability.\nTreeNode(duration::Number, ts::TimeStructure, probability::Vector{<:Float64}, children::TreeNode): a TreeNode with len children, each with the same structure but a different probability.\nTreeNode(duration::Number, ts::TimeStructure, children::Vector{<:TreeNode}) corresponds to a number of different children with different structures, but the same probability.\nTreeNode(duration::Number, ts::TimeStructure, probability::Vector{<:Float64}, children::TreeNode): a TreeNode with length(probability) children, each with the same structure but a different probability.\nTreeNode(duration::Number, ts::TimeStructure, probability::Vector{<:Float64}, children::Vector{<:TreeNode}): a TreeNode with length(probability) children, each with a different structure and probability.\n\nExample\n\nday = SimpleTimes(24, 1)\n# Provides a leaf node\nTreeNode(2, day)\n\n# Provides a linear node structure\nTreeNode(2, day, TreeNode(2, day))\n\n# Provides a tree node with two children with 70 % and 30 % probability, respectively\nTreeNode(2, day, [0.7, 0.3], TreeNode(2, SimpleTimes(24, 1)))\n\n\n# Provide a tree node with two children with 70 % (168 periods) and 30 % (24 periods)\n# probability, respectively\nTreeNode(2, day, [0.7, 0.3], [\n    TreeNode(2, SimpleTimes(168, 1)),\n    TreeNode(2, SimpleTimes(24, 1)),\n])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.regular_tree","page":"API reference","title":"TimeStruct.regular_tree","text":"regular_tree(\n    duration::S,\n    branching::Vector,\n    ts::OP;\n    op_per_strat::Real=1.0,\n) where {S,T,OP<:TimeStructure{T}}\n\nFunction for creating a regular tree with a uniform structure for each strategic period.\n\nEach strategic period is of equal length as given by duration and will have the same operational time structure ts. The vector branching specifies the number of branchings at each stage of the tree, excluding the first stage. The branches at each stage will all have equal probability.\n\nnote: Deprecated function\nThis function is deprecated and will be removed in a later release. The new function is given byTwoLevelTree(duration, branching, ts; op_per_strat)\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.mult_scen","page":"API reference","title":"TimeStruct.mult_scen","text":"mult_scen(scen)\n\nReturns the multiplication factor to be used for this scenario when comparing with the overall set of operational scenarios.\n\nIf all scenarios in a set of operational scenarios are of equal duration (preferred usage), this factor is equal to one. Otherwise this factor would be equal to the ratio of the scenario with longest duration to the duration of the given scenario.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.mult_repr","page":"API reference","title":"TimeStruct.mult_repr","text":"mult_repr(rp)\n\nReturns the multiplication factor to be used for this representative period when comparing with the representative periods structure it is part of.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.mult_strat","page":"API reference","title":"TimeStruct.mult_strat","text":"mult_strat(sp)\n\nReturns the multiplication factor to be used for this strategic period when comparing the duration of the strategic period to the duration of the time structure being used for the strategic period.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.probability_scen","page":"API reference","title":"TimeStruct.probability_scen","text":"probability_scen(scen)\n\nThe probability of a single scenario in a set of operational scenarios.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.probability_branch","page":"API reference","title":"TimeStruct.probability_branch","text":"probability_branch(t::Union{TimePeriod, TimeStructurePeriod})\n\nReturns the branch probability associated with the time period or time structure period\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.n_strat_per","page":"API reference","title":"TimeStruct.n_strat_per","text":"n_strat_per(ts::TwoLevelTree)\n\nReturns the number of strategic periods of a TwoLevelTree. If the number is different for the individual branches, it returns the maximum value.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.n_children","page":"API reference","title":"TimeStruct.n_children","text":"n_children(n::StratNode, ts::TwoLevelTree)\n\nReturns the number of children of a StratNode.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.n_leaves","page":"API reference","title":"TimeStruct.n_leaves","text":"n_leaves(ts::TwoLevelTree)\n\nReturns the number of children of a TwoLevelTree.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.n_branches","page":"API reference","title":"TimeStruct.n_branches","text":"n_branches(ts::TwoLevelTree, sp::Int)\n\nReturns the number of branches in strategic period sp of a TwoLevelTree.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.repr_periods","page":"API reference","title":"TimeStruct.repr_periods","text":"repr_periods(ts::TimeStructure)\n\nThis function returns a type for iterating through the individual representative periods of a TimeStructure. The type of the iterator is dependent on the type of the input TimeStructure.\n\nWhen the TimeStructure is a TimeStructure, repr_periods returns a SingleReprPeriodWrapper. This corresponds to the default behavior.\n\n\n\n\n\nWhen the TimeStructure is a RepresentativePeriods, repr_periods returns the iterator ReprPers.\n\n\n\n\n\nWhen the TimeStructure is a StrategicPeriod, repr_periods returns the iterator StratReprPers.\n\n\n\n\n\nWhen the TimeStructure is a SingleStrategicPeriod, repr_periods returns the correct behavior based on the substructure.\n\n\n\n\n\nWhen the TimeStructure is a TwoLevel, repr_periods returns an Array of all StratReprPeriods.\n\n\n\n\n\nWhen the TimeStructure is a StratNode, repr_periods returns the iterator StratNodeReprPers.\n\n\n\n\n\nWhen the TimeStructure is a TwoLevelTree, StratScens, or a StrategicScenario, repr_periods returns an Array of all StratNodeReprPeriods.\n\nThese are equivalent to a StratReprPeriod of a TwoLevel time structure.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.opscenarios","page":"API reference","title":"TimeStruct.opscenarios","text":"opscenarios(ts::TimeStructure)\n\nThis function returns a type for iterating through the individual operational scenarios of a TimeStructure. The type of the iterator is dependent on the type of the input TimeStructure.\n\nWhen the TimeStructure is a TimeStructure, opscenarios returns a SingleScenarioWrapper. This corresponds to the default behavior.\n\n\n\n\n\nWhen the TimeStructure is an OperationalScenarios, opscenarios returns the iterator OpScens.\n\n\n\n\n\nWhen the TimeStructure is a RepresentativePeriod with OperationalScenarios, opscenarios returns the iterator RepOpScens.\n\n\n\n\n\nWhen the TimeStructure is a SingleReprPeriod, opscenarios returns the correct behavior based on the substructure.\n\n\n\n\n\nWhen the TimeStructure is a RepresentativePeriods, opscenarios returns an Array of all ReprOpScenarios.\n\n\n\n\n\nWhen the TimeStructure is a StrategicPeriod, opscenarios returns the iterator StratOpScens.\n\n\n\n\n\nWhen the TimeStructure is a StrategicPeriod with RepresentativePeriods, opscenarios returns a vector of StratReprOpScenarios.\n\n\n\n\n\nWhen the TimeStructure is a SingleStrategicPeriod, opscenarios returns the correct behavior based on the substructure.\n\n\n\n\n\nWhen the TimeStructure is a TwoLevel, opscenarios returns a vector of StratOpScenarios or a a vector of StratReprOpScenarios depending on whether the TimeStructure includes RepresentativePeriods or not.\n\n\n\n\n\nWhen the TimeStructure is a StratNode, opscenarios returns the iterator StratNodeOpScens.\n\n\n\n\n\nWhen the TimeStructure is a StratNodeReprPeriod with a RepresentativePeriod, opscenarios returns the iterator StratNodeReprOpScens.\n\n\n\n\n\nWhen the TimeStructure is a StratNodeReprPeriod with a SingleReprPeriod, opscenarios returns the iterator StratNodeOpScens as the overall time structure does not include representative periods.\n\n\n\n\n\nWhen the TimeStructure is a StratNode with RepresentativePeriods, opscenarios returns an Array of all StratNodeReprOpScenarios.\n\n\n\n\n\nWhen the TimeStructure is a TwoLevelTree, StratScens, or a StrategicScenario, opscenarios returns an Array of all StratNodeOpScenarios or StratNodeReprOpScenarios types, depending on whether the TimeStructure includes RepresentativePeriods or not.\n\nThese are equivalent to a StratOpScenario and StratReprOpScenario of a TwoLevel time structure.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.strat_periods","page":"API reference","title":"TimeStruct.strat_periods","text":"strat_periods(ts::TimeStructure)\n\nThis function returns a type for iterating through the individual strategic periods of a TimeStructure. The type of the iterator is dependent on the type of the input TimeStructure. The elements returned of the iterator will be subtypes of AbstractStrategicPeriod.\n\nWhen the TimeStructure is a TimeStructure, strat_periods returns a SingleStrategicPeriodWrapper. This corresponds to the default behavior.\n\n\n\n\n\nWhen the TimeStructure is a TwoLevel, strat_periods returns the iterator StratPers.\n\nExample\n\nperiods = TwoLevel(5, SimpleTimes(10,1))\ntotal_dur = sum(duration_strat(sp) for sp in strategic_periods(periods))\n\n\n\n\n\nWhen the TimeStructure is a TwoLevelTree, strat_periods returns a StratTreeNodes type, which, through iteration, provides StratNode types.\n\nThese are equivalent to a StrategicPeriod of a TwoLevel time structure.\n\n\n\n\n\nWhen the TimeStructure is a SingleStrategicScenario or SingleStrategicScenarioWrapper, strat_periods returns the value of its internal TimeStructure.\n\n\n\n\n\nWhen the TimeStructure is a StrategicScenario, strat_periods returns a ScenTreeNodes type, which, through iteration, provides StratNode types.\n\nThese are equivalent to a StrategicPeriod of a TwoLevel time structure.\n\n\n\n\n\nWhen the TimeStructure is a StratScens, strat_periods returns a StratTreeNodes type, which, through iteration, provides StratNode types.\n\nThese are equivalent to a StrategicPeriod of a TwoLevel time structure.\n\nnote: Note\nThe corresponding StratTreeNodes type is equivalent to the created StratTreeNodes when using strat_periods directly on the TwoLevelTree.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.strategic_periods","page":"API reference","title":"TimeStruct.strategic_periods","text":"strategic_periods(ts)\n\nConvenience constructor for strat_periods. Both names can be used interchangable.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.strategic_scenarios","page":"API reference","title":"TimeStruct.strategic_scenarios","text":"strategic_scenarios(ts::TimeStructure)\n\nThis function returns a type for iterating through the individual strategic scenarios of a TwoLevelTree. The type of the iterator is dependent on the type of the input TimeStructure.\n\nWhen the TimeStructure is a TimeStructure, strategic_scenarios returns a SingleStrategicScenarioWrapper. This corresponds to the default behavior.\n\n\n\n\n\nWhen the TimeStructure is a TwoLevelTree, strategic_scenarios returns the iterator StratScens.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.withprev","page":"API reference","title":"TimeStruct.withprev","text":"withprev(iter)\n\nIterator wrapper that yields (prev, t) where prev is the previous time period or nothing for the first time period.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.withnext","page":"API reference","title":"TimeStruct.withnext","text":"withnext(iter)\n\nIterator wrapper that yields (t, next) where next is the next time period or nothing for the last time period.\n\nNote that this iterator can not be used when iterating the nodes of a strategic tree structure, as the next node is not uniquely defined in that case.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.chunk","page":"API reference","title":"TimeStruct.chunk","text":"chunk(iter, n; cyclic = false)\n\nIterator wrapper that yields chunks where each chunk is an iterator over at most n consecutive time periods starting at each time period of the original iterator.\n\nIt is possible to get the n consecutive time periods in a cyclic fashion, by setting cyclic to true.\n\nwarning: TwoLevelTree\nUsage of the function for the strategic periods of a TwoLevelTree time structure results in an error.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.chunk_duration","page":"API reference","title":"TimeStruct.chunk_duration","text":"chunk_duration(iter, dur)\n\nIterator wrapper that yields chunks based on duration where each chunk is an iterator over the following time periods until at least dur time is covered or the end is reached.\n\nwarning: TwoLevelTree\nUsage of the function for the strategic periods of a TwoLevelTree time structure results in an error.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.duration","page":"API reference","title":"TimeStruct.duration","text":"duration(t::TimePeriod)\n\nThe duration of a time period in number of operational time units.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.isfirst","page":"API reference","title":"TimeStruct.isfirst","text":"isfirst(t::TimePeriod)\n\nReturns true if the time period is the first in a sequence and has no previous time period\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.multiple","page":"API reference","title":"TimeStruct.multiple","text":"multiple(t::TimePeriod)\n\nReturns the number of times a time period should be counted for the whole time structure.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.multiple_strat","page":"API reference","title":"TimeStruct.multiple_strat","text":"multiple_strat(sp::AbstractStrategicPeriod, t)\n\nReturns the number of times a time period t should be accounted for when accumulating over one single unit of strategic time.\n\nExample\n\nperiods = TwoLevel(10, 1, SimpleTimes(24,1); op_per_strat = 8760)\nfor sp in strategic_periods(periods)\n    hours_per_year = sum(duration(t) * multiple_strat(sp, t) for t in sp)\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.probability","page":"API reference","title":"TimeStruct.probability","text":"probability(t::TimePeriod)\n\nReturns the probability associated with the time period.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.start_oper_time","page":"API reference","title":"TimeStruct.start_oper_time","text":"start_oper_time(t, ts)\n\nGet the operational start time of the time period t in the time structure ts.\n\nThe operational start time is equal to the sum of the durations of all previous operational time periods in its operational time structure.\n\nwarning: Warning\nThe current implementation is not computationally efficient and should be avoided if using this in loops for time structures with many time periods. If this is the case, consider implementing a local tracking of start time using the duration of the time periods.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.end_oper_time","page":"API reference","title":"TimeStruct.end_oper_time","text":"end_oper_time(t, ts)\n\nGet the operational end time of the time period t in the time structure ts.\n\nThe operational end time is equal to the sum of the durations of all previous operational time periods in its operational time structure, including its own duration.\n\nwarning: Warning\nThe current implementation is not computationally efficient and should be avoided if using this in loops for time structures with many time periods. If this is the case, consider implementing a local tracking of end time using the duration of the time periods.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.FixedProfile","page":"API reference","title":"TimeStruct.FixedProfile","text":"FixedProfile(val)\n\nTime profile with a constant value for all time periods.\n\nExample\n\nprofile = FixedProfile(5)\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.OperationalProfile","page":"API reference","title":"TimeStruct.OperationalProfile","text":"OperationalProfile(vals::Vector{T}) where {T}\n\nTime profile with a value that varies with the operational time period. This profile cannot be accessed using AbstractOperationalScenario, AbstractRepresentativePeriod, or AbstractStrategicPeriod.\n\nIf too few values are provided, the last provided value will be repeated.\n\nExample\n\nprofile = OperationalProfile([1, 2, 3, 4, 5])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.RepresentativeProfile","page":"API reference","title":"TimeStruct.RepresentativeProfile","text":"RepresentativeProfile(vals::Vector{P}) where {T, P<:TimeProfile{T}}\nRepresentativeProfile(vals::Vector)\n\nTime profile with a separate time profile for each representative period. This profile cannot be accessed using AbstractStrategicPeriod.\n\nIf too few profiles are provided, the last given profile will be repeated.\n\nExample\n\n# Varying values in each representative period\nprofile = RepresentativeProfile([OperationalProfile([1, 2]), OperationalProfile([3, 4, 5])])\n # The same value in each representative period\nprofile = RepresentativeProfile([1, 2, 3, 4, 5])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.ScenarioProfile","page":"API reference","title":"TimeStruct.ScenarioProfile","text":"ScenarioProfile(vals::Vector{P}) where {T, P<:TimeProfile{T}}\nScenarioProfile(vals::Vector)\n\nTime profile with a separate time profile for each scenario. This profile cannot be accessed using AbstractRepresentativePeriod or AbstractStrategicPeriod.\n\nIf too few profiles are provided, the last given profile will be repeated.\n\nExample\n\n# Varying values in each operational scenario\nprofile = ScenarioProfile([OperationalProfile([1, 2]), OperationalProfile([3, 4, 5])])\n # The same value in each operational scenario\nprofile = ScenarioProfile([1, 2, 3, 4, 5])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.StrategicProfile","page":"API reference","title":"TimeStruct.StrategicProfile","text":"StrategicProfile(vals::Vector{P}) where {T, P<:TimeProfile{T}}\nStrategicProfile(vals::Vector)\n\nTime profile with a separate time profile for each strategic period.\n\nIf too few profiles are provided, the last given profile will be repeated.\n\nExample\n\n# Varying values in each strategic period\nprofile = StrategicProfile([OperationalProfile([1, 2]), OperationalProfile([3, 4, 5])])\n # The same value in each strategic period\nprofile = StrategicProfile([1, 2, 3, 4, 5])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.StrategicStochasticProfile","page":"API reference","title":"TimeStruct.StrategicStochasticProfile","text":"StrategicStochasticProfile(vals::Vector{<:Vector{P}}) where {T, P<:TimeProfile{T}}\nStrategicStochasticProfile(vals::Vector{<:Vector})\n\nTime profile with a separate time profile for each strategic node in a TwoLevelTree structure.\n\nIf too few profiles are provided, the last given profile will be repeated, both for strategic periods and branches within a strategic period.\n\nExample\n\n # The same value in each strategic period and branch\nprofile = StrategicStochasticProfile([[1], [21, 22]])\n# Varying values in each strategic period and branch\nprofile = StrategicStochasticProfile([\n    [OperationalProfile([11, 12])],\n    [OperationalProfile([21, 22]), OperationalProfile([31, 32])]\n])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.Discounter","page":"API reference","title":"TimeStruct.Discounter","text":"Discounter(discount_rate, ts::TimeStructure)\nDiscounter(discount_rate, timeunit_to_year, ts::TimeStructure)\n\nStructure to hold discount information to be used for a time structure ts. The discount_rate is an absolute discount rate while the parameter timeunit_to_year is used convert the time units of strategic periods in the time structure to years (default value = 1.0).\n\nAs an example, consider the following time structure:\n\n# Modeling of a day with hourly resolution for 50 years with a resolution of 5 years\nperiods = TwoLevel(10, 5 * 8760, SimpleTimes(24, 1))\n\n# The parameter `timeunit_to_year` must in this case be 1 year / 8760 h\ndisc = Discounter(0.04, 1 / 8760, periods)\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#TimeStruct.discount","page":"API reference","title":"TimeStruct.discount","text":"discount(t::Union{TimePeriod,TimeStructurePeriod}, time_struct::TimeStructure, discount_rate; type = \"start\", timeunit_to_year=1.0)\ndiscount(disc::Discounter, t::Union{TimePeriod,TimeStructurePeriod}; type = \"start\")\n\nCalculates the discount factor to be used for a time period t using a fixed discount_rate. The function can be either called using a Discounter type or by specifying the parameters (time structure ts, discount_rate and potentially timeunit_to_year) directly.\n\nThere are two types of discounting available:\n\nDiscounting to the start of the strategic period containing the time period:\nThis can be achieved through specifying type=\"start\". It is useful for investment costs\nDiscounting to the average of the over the whole strategic period:\nThe average can be calculated either as a continuous average (type=\"avg\") or as a discrete average that discounts to the start of each year (type=\"avg_year\"). Average discounting is useful for operational costs.\n\nThe timeunit_to_year parameter is used to convert the time units of strategic periods in the time structure to years (default value = 1.0).\n\ntip: Comparison with `objective_weight`\nBoth objective_weight and discount can serve similar purposes. Compared to objective_weight, discount only calculates the discount factor for a given time period. If t is an AbstractStrategicPeriod, both are equivalent.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#TimeStruct.objective_weight","page":"API reference","title":"TimeStruct.objective_weight","text":"objective_weight(t::Union{TimePeriod,TimeStructurePeriod}, ts::TimeStructure, discount_rate; type = \"start\", timeunit_to_year = 1.0)\nobjective_weight(t::Union{TimePeriod,TimeStructurePeriod}, disc::Discounter; type = \"start\")\n\nCalculates the overall objective weight for a time period t using a fixed discount_rate. The weight considers both discounting, the probability, and potential multiplicity of t. The function can be either called using a Discounter type or by specifying the parameters (time structure ts, discount_rate and potentially timeunit_to_year) directly.\n\nThere are two types of discounting available:\n\nDiscounting to the start of the strategic period containing the time period:\nThis can be achieved through specifying type=\"start\". It is useful for investment costs\nDiscounting to the average of the over the whole strategic period:\nThe average can be calculated either as a continuous average (type=\"avg\") or as a discrete average that discounts to the start of each year (type=\"avg_year\"). Average discounting is useful for operational costs.\n\nThe timeunit_to_year parameter is used to convert the time units of strategic periods in the time structure to years (default value = 1.0).\n\ntip: Comparison with `discount`\nBoth discount and objective_weight can serve similar purposes. Compared to discount, objective_weight includes as well the probability and multiplicity of a given time period. If t is an AbstractStrategicPeriod, both are equivalent.\n\n\n\n\n\n","category":"function"},{"location":"reference/internal/#int-types","page":"Internal reference","title":"Internal types","text":"","category":"section"},{"location":"reference/internal/#int-types-super","page":"Internal reference","title":"Internal supertypes","text":"","category":"section"},{"location":"reference/internal/#int-types-twoleveltree","page":"Internal reference","title":"Strategic period types (TwoLevelTree)","text":"","category":"section"},{"location":"reference/internal/#int-types-twoleveltree-single","page":"Internal reference","title":"Single types","text":"","category":"section"},{"location":"reference/internal/#int-types-twoleveltree-iter","page":"Internal reference","title":"Iterator types","text":"","category":"section"},{"location":"reference/internal/#int-types-strat_twolevel","page":"Internal reference","title":"Strategic period types (TwoLevel)","text":"","category":"section"},{"location":"reference/internal/#int-types-strat_twolevel-single","page":"Internal reference","title":"Single types","text":"","category":"section"},{"location":"reference/internal/#int-types-strat_twolevel-iter","page":"Internal reference","title":"Iterator types","text":"","category":"section"},{"location":"reference/internal/#int-types-repr","page":"Internal reference","title":"Representative period types","text":"","category":"section"},{"location":"reference/internal/#int-types-repr-single","page":"Internal reference","title":"Single types","text":"","category":"section"},{"location":"reference/internal/#int-types-repr-iter","page":"Internal reference","title":"Iterator types","text":"","category":"section"},{"location":"reference/internal/#int-types-osc","page":"Internal reference","title":"Operational scenarios types","text":"","category":"section"},{"location":"reference/internal/#int-types-osc-single","page":"Internal reference","title":"Single types","text":"","category":"section"},{"location":"reference/internal/#int-types-osc-iter","page":"Internal reference","title":"Iterator types","text":"","category":"section"},{"location":"reference/internal/#int-types-periods","page":"Internal reference","title":"Operational period types","text":"","category":"section"},{"location":"reference/internal/#TimeStruct.TimeStructurePeriod","page":"Internal reference","title":"TimeStruct.TimeStructurePeriod","text":"abstract type TimeStructurePeriod{T} <: TimeStructure{T}\n\nAbstract type representing different time structures that consists of one or more time periods. It is used for TimeStructures that can also act as index for periods, e.g., AbstractStrategicPeriod.\n\nThe type 'T' gives the data type used for the duration of the time periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.TimeStructInnerIter","page":"Internal reference","title":"TimeStruct.TimeStructInnerIter","text":"abstract type TimeStructInnerIter{T<:Duration}\n\nAbstract type representing different iterators for individual time structures. The difference to TimeStructure is that iterating through a TimeStructInnerIter will not provide a TimePeriod, but a TimeStructure.\n\nnote: Note\nTimeStructInnerIter and TimeStructOuterIter are comparable. The former is implemented for the inner level, that is if you want to use, e.g., opscenarios(OperationalScenarios()) while the latter is used for the outer level, e.g., opscenarios(StrategicPeriod()).\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.TimeStructOuterIter","page":"Internal reference","title":"TimeStruct.TimeStructOuterIter","text":"abstract type TimeStructOuterIter{T<:Duration}\n\nAbstract type representing different iterators for individual time structures. The difference to TimeStructure is that iterating through a TimeStructOuterIter will not provide a TimePeriod, but a TimeStructure.\n\nnote: Note\nTimeStructInnerIter and TimeStructOuterIter are comparable. The former is implemented for the inner level, that is if you want to use, e.g., opscenarios(OperationalScenarios()) while the latter is used for the outer level, e.g., opscenarios(StrategicPeriod()).\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.AbstractTreeNode","page":"Internal reference","title":"TimeStruct.AbstractTreeNode","text":"abstract type AbstractTreeNode{S,T} <: AbstractStrategicPeriod{S,T}\n\nAbstract base type for all tree nodes within a TwoLevelTree type.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.AbstractStrategicScenario","page":"Internal reference","title":"TimeStruct.AbstractStrategicScenario","text":"abstract type AbstractStrategicScenario{T} <: TimeStructurePeriod{T}\n\nAbstract type used for time structures that represent a strategic scenario. These periods are obtained when iterating through the strategic scenarios of a time structure declared by the function strategic_scenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNode","page":"Internal reference","title":"TimeStruct.StratNode","text":"struct StratNode{S, T, OP<:TimeStructure{T}} <: AbstractTreeNode{S,T}\n\nA structure representing a single strategic node of a TwoLevelTree. It is created through iterating through StratTreeNodes.\n\nIt is equivalent to a StrategicPeriod of a TwoLevel time structure when utilizing a TwoLevelTree.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StrategicScenario","page":"Internal reference","title":"TimeStruct.StrategicScenario","text":"struct StrategicScenario{S,T,OP<:AbstractTreeNode{S,T}} <: AbstractStrategicScenario{T}\n\nDescription of an individual strategic scenario. It includes all strategic nodes corresponding to a scenario, including the probability. It can be utilized within a decomposition algorithm.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SingleStrategicScenario","page":"Internal reference","title":"TimeStruct.SingleStrategicScenario","text":"struct SingleStrategicScenario{T,SC<:TimeStructure{T}} <: AbstractStrategicScenario{T}\n\nA type representing a single strategic scenario supporting iteration over its time periods. It is created when iterating through SingleStrategicScenarioWrapper.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.AbstractTreeStructure","page":"Internal reference","title":"TimeStruct.AbstractTreeStructure","text":"abstract type AbstractTreeStructure{T} <: TimeStructOuterIter{T}\n\nAbstract base type for all tree timestructures within a TwoLevelTree type.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.AbstractStratScens","page":"Internal reference","title":"TimeStruct.AbstractStratScens","text":"abstract type AbstractStratScens{S,T} <: TimeStructInnerIter\n\nAbstract type used for time structures that represent a collection of strategic scenarios, obtained through calling the function strategic_scenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratTreeNodes","page":"Internal reference","title":"TimeStruct.StratTreeNodes","text":"struct StratTreeNodes{S,T,OP<:TimeStructure{T}} <: AbstractStratPers{T}\n\nType for iterating through the individual strategic nodes of a TwoLevelTree. It is automatically created through the function strat_periods, and hence, strategic_periods.\n\nIterating through StratTreeNodes using the WithPrev iterator changes the behavior, although the meaning remains unchanged.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratScens","page":"Internal reference","title":"TimeStruct.StratScens","text":"struct StratScens{S,T,OP<:AbstractTreeNode{S,T}} <: AbstractStratScens{T}\n\nType for iteration through the individual strategic scenarios represented as StrategicScenario.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.ScenTreeNodes","page":"Internal reference","title":"TimeStruct.ScenTreeNodes","text":"struct ScenTreeNodes{S,T,N,OP<:AbstractTreeNode{S,T}} <: AbstractStratPers{T}\n\nType for iterating through the individual strategic nodes of a StrategicScenario. It is automatically created through the function strat_periods, and hence, strategic_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SingleStrategicScenarioWrapper","page":"Internal reference","title":"TimeStruct.SingleStrategicScenarioWrapper","text":"struct SingleStrategicScenarioWrapper{T,SC<:TimeStructure{T}} <: AbstractStratScens{T}\n\nType for iterating through the individual strategic periods of a time structure without TwoLevelTree. It is automatically created through the function strategic_scenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.AbstractStrategicPeriod","page":"Internal reference","title":"TimeStruct.AbstractStrategicPeriod","text":"abstract type AbstractStrategicPeriod{S,T} <: TimeStructurePeriod{T}\n\nAbstract type used for time structures that represent a strategic period. These periods are obtained when iterating through the strategic periods of a time structure declared by the function strat_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SingleStrategicPeriod","page":"Internal reference","title":"TimeStruct.SingleStrategicPeriod","text":"struct SingleStrategicPeriodWrapper{T,SP<:TimeStructure{T}} <: AbstractStrategicPeriod{T,T}\n\nA type representing a single strategic period supporting iteration over its time periods. It is created when iterating through SingleStrategicPeriodWrapper.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StrategicPeriod","page":"Internal reference","title":"TimeStruct.StrategicPeriod","text":"struct StrategicPeriod{S,T,OP<:TimeStructure{T}} <: AbstractStrategicPeriod{S,T}\n\nA type representing a single strategic period supporting iteration over its time periods. It is created when iterating through StratPers.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.AbstractStratPers","page":"Internal reference","title":"TimeStruct.AbstractStratPers","text":"abstract type AbstractStratPers{S,T} <: TimeStructInnerIter\n\nAbstract type used for time structures that represent a collection of strategic periods, obtained through calling the function strat_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SingleStrategicPeriodWrapper","page":"Internal reference","title":"TimeStruct.SingleStrategicPeriodWrapper","text":"struct SingleStrategicPeriodWrapper{T,SP<:TimeStructure{T}} <: AbstractStratPers{T}\n\nType for iterating through the individual strategic periods of a time structure without TwoLevel. It is automatically created through the function strat_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratPers","page":"Internal reference","title":"TimeStruct.StratPers","text":"struct StratPers{S,T,OP} <: AbstractStratPers{T}\n\nType for iterating through the individual strategic periods of a TwoLevel time structure. It is automatically created through the function strat_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.AbstractRepresentativePeriod","page":"Internal reference","title":"TimeStruct.AbstractRepresentativePeriod","text":"abstract type AbstractRepresentativePeriod{T} <: TimeStructurePeriod{T}\n\nAbstract type used for time structures that represent a representative period. These periods are obtained when iterating through the representative periods of a time structure declared by the function repr_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SingleReprPeriod","page":"Internal reference","title":"TimeStruct.SingleReprPeriod","text":"struct SingleReprPeriod{T,OP<:TimeStructure{T}} <: AbstractRepresentativePeriod{T}\n\nA type representing a single representative period supporting iteration over its time periods. It is created when iterating through SingleReprPeriodWrapper.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.RepresentativePeriod","page":"Internal reference","title":"TimeStruct.RepresentativePeriod","text":"struct RepresentativePeriod{T,OP<:TimeStructure{T}} <: AbstractRepresentativePeriod{T}\n\nA type representing a single representative period supporting iteration over its time periods. It is created when iterating through ReprPers.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratReprPeriod","page":"Internal reference","title":"TimeStruct.StratReprPeriod","text":"struct StratReprPeriod{T,OP<:TimeStructure{T}} <: AbstractRepresentativePeriod{T}\n\nA type representing a single representative period supporting iteration over its time periods. It is created when iterating through StratReprPers.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNodeReprPeriod","page":"Internal reference","title":"TimeStruct.StratNodeReprPeriod","text":"struct StratNodeReprPeriod{T,OP<:TimeStructure{T}} <: AbstractRepresentativePeriod{T}\n\nA structure representing a single representative period of a StratNode of a TwoLevelTree. It is created through iterating through StratNodeReprPers.\n\nIt is equivalent to a StratReprPeriod of a TwoLevel time structure when utilizing a TwoLevelTree.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SingleReprPeriodWrapper","page":"Internal reference","title":"TimeStruct.SingleReprPeriodWrapper","text":"struct SingleReprPeriodWrapper{T,OP<:TimeStructure{T}} <: TimeStructInnerIter{T}\n\nType for iterating through the individual representative periods of a time structure without RepresentativePeriods. It is automatically created through the function repr_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.ReprPers","page":"Internal reference","title":"TimeStruct.ReprPers","text":"struct ReprPers{S,T,OP} <: TimeStructInnerIter{T}\n\nType for iterating through the individual representative periods of a RepresentativePeriods time structure. It is automatically created through the function repr_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratReprPers","page":"Internal reference","title":"TimeStruct.StratReprPers","text":"struct StratReprPers{T,OP<:TimeStructInnerIter{T}} <: TimeStructOuterIter{T}\n\nType for iterating through the individual representative periods of a StrategicPeriod time structure. It is automatically created through the function repr_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNodeReprPers","page":"Internal reference","title":"TimeStruct.StratNodeReprPers","text":"struct StratNodeReprPers{T,OP<:TimeStructInnerIter{T}} <: AbstractTreeStructure{T}\n\nType for iterating through the individual presentative periods of a StratNode. It is automatically created through the function repr_periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.AbstractOperationalScenario","page":"Internal reference","title":"TimeStruct.AbstractOperationalScenario","text":"abstract type AbstractOperationalScenario{T} <: TimeStructurePeriod{T}\n\nAbstract type used for time structures that represent an operational scenario. These periods are obtained when iterating through the operational scenarios of a time structure declared by the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SingleScenario","page":"Internal reference","title":"TimeStruct.SingleScenario","text":"struct SingleScenario{T,SC<:TimeStructure{T}} <: AbstractRepresentativePeriod{T}\n\nA type representing a single operational scenario supporting iteration over its time periods. It is created when iterating through SingleScenarioWrapper.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.OperationalScenario","page":"Internal reference","title":"TimeStruct.OperationalScenario","text":"struct OperationalScenario{T,OP<:TimeStructure{T}} <: AbstractOperationalScenario{T}\n\nA type representing a single operational scenario supporting iteration over its time periods. It is created when iterating through OpScens.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.ReprOpScenario","page":"Internal reference","title":"TimeStruct.ReprOpScenario","text":"struct ReprOpScenario{T,OP<:TimeStructure{T}} <: AbstractOperationalScenario{T}\n\nA type representing a single operational scenarios supporting iteration over its time periods. It is created when iterating through RepOpScens.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratOpScenario","page":"Internal reference","title":"TimeStruct.StratOpScenario","text":"struct StratOpScenario{T,OP<:TimeStructure{T}} <: AbstractOperationalScenario{T}\n\nA type representing a single operational scenario supporting iteration over its time periods. It is created when iterating through StratOpScens.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratReprOpScenario","page":"Internal reference","title":"TimeStruct.StratReprOpScenario","text":"struct StratReprOpScenario{T, OP<:TimeStructure{T}} <: AbstractRepresentativePeriod{T}\n\nA type representing a single representative period supporting iteration over its time periods. It is created when iterating through StratReprPers.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNodeOpScenario","page":"Internal reference","title":"TimeStruct.StratNodeOpScenario","text":"struct StratNodeOpScenario{T,OP<:TimeStructure{T}}  <: AbstractOperationalScenario{T}\n\nA structure representing a single operational scenario for a strategic node supporting iteration over its time periods. It is created through iterating through StratNodeOpScens.\n\nIt is equivalent to a StratOpScenario of a TwoLevel time structure when utilizing a TwoLevelTree.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNodeReprOpScenario","page":"Internal reference","title":"TimeStruct.StratNodeReprOpScenario","text":"struct StratNodeReprOpScenario{T} <: AbstractOperationalScenario{T}\n\nA structure representing a single operational scenario for a representative period in A TwoLevelTree structure supporting iteration over its time periods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SingleScenarioWrapper","page":"Internal reference","title":"TimeStruct.SingleScenarioWrapper","text":"struct SingleScenarioWrapper{T,OP<:TimeStructure{T}} <: TimeStructInnerIter{T}\n\nType for iterating through the individual operational scenarios of a time structure without OperationalScenarios. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.OpScens","page":"Internal reference","title":"TimeStruct.OpScens","text":"struct OpScens{T,OP} <: TimeStructInnerIter{T}\n\nType for iterating through the individual operational scenarios of a OperationalScenarios time structure. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.RepOpScens","page":"Internal reference","title":"TimeStruct.RepOpScens","text":"struct RepOpScens{T,OP<:TimeStructInnerIter{T}} <: TimeStructOuterIter{T}\n\nType for iterating through the individual operational scenarios of a RepresentativePeriod time structure. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratOpScens","page":"Internal reference","title":"TimeStruct.StratOpScens","text":"struct StratOpScens{T,OP<:TimeStructInnerIter{T}} <: TimeStructOuterIter{T}\n\nType for iterating through the individual operational scenarios of a StrategicPeriod time structure. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratReprOpScens","page":"Internal reference","title":"TimeStruct.StratReprOpScens","text":"struct StratReprOpScens{T,OP<:TimeStructInnerIter{T}} <: TimeStructOuterIter{T}\n\nType for iterating through the individual operational scenarios of a StrategicPeriod time structure with RepresentativePeriods. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNodeOpScens","page":"Internal reference","title":"TimeStruct.StratNodeOpScens","text":"struct StratNodeOpScens{T,OP<:TimeStructInnerIter{T}} <: AbstractTreeStructure{T}\n\nType for iterating through the individual operational scenarios of a StratNode. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.StratNodeReprOpScens","page":"Internal reference","title":"TimeStruct.StratNodeReprOpScens","text":"struct StratNodeReprOpScens{T,OP<:TimeStructInnerIter{T}} <: AbstractTreeStructure{T}\n\nType for iterating through the individual operational scenarios of a StratNodeReprPeriod. It is automatically created through the function opscenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.TimePeriod","page":"Internal reference","title":"TimeStruct.TimePeriod","text":"abstract type TimePeriod\n\nAbstract type used for a uniform interface for iterating through time structures and indexing of time profiles.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.SimplePeriod","page":"Internal reference","title":"TimeStruct.SimplePeriod","text":"struct SimplePeriod{T<:Number} <: TimePeriod\n\nTime period for a single operational period. It is created through iterating through a SimpleTimes time structure.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.CalendarPeriod","page":"Internal reference","title":"TimeStruct.CalendarPeriod","text":"struct CalendarPeriod{T} <: TimePeriod\n\nTime period for a single operational period. It is created through iterating through a CalendarTimes time structure with duration measured in hours (by default).\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.ScenarioPeriod","page":"Internal reference","title":"TimeStruct.ScenarioPeriod","text":"struct ScenarioPeriod{P} <: TimePeriod where {P<:TimePeriod}\n\nTime period for a single operational period. It is created through iterating through a OperationalScenarios time structure. It is as well created as period within OperationalPeriod when the time structure includes OperationalScenarios.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.ReprPeriod","page":"Internal reference","title":"TimeStruct.ReprPeriod","text":"struct ReprPeriod{P} <: TimePeriod where {P<:TimePeriod}\n\nTime period for a single operational period. It is created through iterating through a RepresentativePeriods time structure. It is as well created as period within OperationalPeriod when the time structure includes RepresentativePeriods.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.OperationalPeriod","page":"Internal reference","title":"TimeStruct.OperationalPeriod","text":"struct OperationalPeriod{P} <: TimePeriod where {P<:TimePeriod}\n\nTime period for a single operational period. It is created through iterating through a TwoLevel time structure.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#TimeStruct.TreePeriod","page":"Internal reference","title":"TimeStruct.TreePeriod","text":"struct TreePeriod{P} <: TimePeriod where {P<:TimePeriod}\n\nTime period for iteration of a TwoLevelTree time structure. This period has in addition to an operational period also the two fields branch and prob_branch corresponding to the respective branch and probability of the branch\n\nwarn: Using OperationalScenarios\nThe probability will always only correspond to the branch probability, even when you utilize OperationalScenarios.  Using the function probability includes however the scenario probability.\n\n\n\n\n\n","category":"type"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"Welcome to the documentation of the TimeStruct package!","category":"section"},{"location":"#What-is-TimeStruct?","page":"Introduction","title":"What is TimeStruct?","text":"TimeStruct is a Julia package that supports the efficient development of optimization models with multi-horizon time modeling. The package is designed to be used in combination with JuMP for optimization modeling in Julia.\n\nThe main concept is a TimeStructure which is an abstract type that enables iteration over a sequence of time periods. These time periods can serve as indices for optimization variables and can also facilitate the lookup of associated data values from time-varying profiles. By having a well-defined interface that is supported by all time structures, optimization models that are valid for arbitrary time structures can be written. The following example shows how a small optimization model can be set up in a function that accepts a general time structure and cost profile.\n\nusing JuMP, TimeStruct\n\nfunction optimize_model(periods::TimeStructure, cost::TimeProfile)\n    m = Model()\n    @variable(m, x[periods] >= 0)\n    @constraint(m, sum(x[t] for t in periods) >= 10)\n    @objective(m, Min, sum(cost[t] * x[t] for t in periods))\n    return m\nend","category":"section"},{"location":"#Why-use-TimeStruct?","page":"Introduction","title":"Why use TimeStruct?","text":"In complex optimization models, tracking relationships between time periods often requires substantial coding, especially with stochastic versions. Time constraints can introduce subtle bugs, particularly with linking constraints between periods or scenarios, like managing storage inventory or dispatch constraints. Extra indices for time and scenarios complicate the code, making it harder to read, maintain, and adapt.\n\nTimeStruct abstracts time structures, providing a common interface that simplifies the code and supports various time structures (operational, strategic/investment periods, and uncertainties). This abstraction allows modelers to focus on other model properties and facilitates running a single model for different time structures, and aids in the development of decomposition techniques.","category":"section"},{"location":"#How-to-get-started","page":"Introduction","title":"How to get started","text":"The package is registered in the general registry and can be installed in the standard fashion:\n\n] add TimeStruct\n\nThis documentation consists of a manual explaining concepts and giving examples, as well as a complete API reference.","category":"section"},{"location":"#Citation","page":"Introduction","title":"Citation","text":"If you find TimeStruct useful in your work, we kindly request that you cite the following:\n\n@article{Flatberg2025,\n  doi = {10.21105/joss.07578},\n  url = {https://doi.org/10.21105/joss.07578},\n  year = {2025},\n  publisher = {The Open Journal},\n  volume = {10},\n  number = {107},\n  pages = {7578},\n  author = {Truls Flatberg and Julian Straus and Lars Hellemo},\n  title = {TimeStruct.jl -- flexible multi-horizon time modeling in optimization models},\n  journal = {Journal of Open Source Software}\n}","category":"section"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"This material is based upon work supported by the Research Council of Norway through the projects ZeroKyst (328721), MaritimeNH3 (328679) and CleanExport (308811).","category":"section"}]
}
